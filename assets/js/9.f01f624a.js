(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{564:function(a,t,v){a.exports=v.p+"assets/img/image-20200131215729647.bd2ead64.png"},565:function(a,t,v){a.exports=v.p+"assets/img/image-20200131223329897.51b2c7f3.png"},566:function(a,t,v){a.exports=v.p+"assets/img/158914-20200111190734951-1778545782.9faa0e5c.png"},567:function(a,t,v){a.exports=v.p+"assets/img/158914-20200111191733074-1278747187.d18ba189.png"},568:function(a,t,v){a.exports=v.p+"assets/img/158914-20200111191012723-1734997632.4c62a963.png"},569:function(a,t,v){a.exports=v.p+"assets/img/158914-20200111192256900-961952936.b4334aa5.png"},570:function(a,t,v){a.exports=v.p+"assets/img/image-20200201122500398.e27382b3.png"},571:function(a,t,v){a.exports=v.p+"assets/img/image-20200510222717548.49d864f7.png"},648:function(a,t,v){"use strict";v.r(t);var r=v(21),e=Object(r.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("p",[a._v("GC发生在堆区，堆通划分为新生代和老年代两个内存区域")]),a._v(" "),r("h1",{attrs:{id:"垃圾判断"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾判断"}},[a._v("#")]),a._v(" 垃圾判断")]),a._v(" "),r("h2",{attrs:{id:"可达性分析算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法"}},[a._v("#")]),a._v(" 可达性分析算法")]),a._v(" "),r("p",[a._v("用来在GC时判断对象是否需要回收")]),a._v(" "),r("p",[a._v("在JVM中会设立若干种根对象(GC Roots)，当任何一个根对象到某一个对象均不可达（没有"),r("strong",[a._v("引用关系")]),a._v("）时，则认为这个对象是可以被回收的")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("方法栈中的局部变量引用")]),a._v(" "),r("p",[a._v("被正在执行的线程的方法栈中的变量引用")])]),a._v(" "),r("li",[r("p",[a._v("静态变量引用")]),a._v(" "),r("p",[a._v("static声明的类变量，位于方法区中引用")])]),a._v(" "),r("li",[r("p",[a._v("软引用和弱引用")])])]),a._v(" "),r("h2",{attrs:{id:"引用类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#引用类型"}},[a._v("#")]),a._v(" 引用类型")]),a._v(" "),r("p",[a._v("在垃圾判断时，虚拟机根据对象不同的引用类型，执行不同的垃圾回收策略")]),a._v(" "),r("h3",{attrs:{id:"强引用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#强引用"}},[a._v("#")]),a._v(" 强引用")]),a._v(" "),r("p",[a._v("被强引用的对象，不会被垃圾回收")]),a._v(" "),r("h4",{attrs:{id:"用法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用法"}},[a._v("#")]),a._v(" 用法")]),a._v(" "),r("p",[a._v("普通的等号赋值，没有其他修饰")]),a._v(" "),r("h3",{attrs:{id:"软引用-softreference"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#软引用-softreference"}},[a._v("#")]),a._v(" 软引用 SoftReference")]),a._v(" "),r("p",[a._v("正常情况下垃圾回收是不会回收软引用，"),r("strong",[a._v("如果垃圾回收之后，内存空间还是不足以存放新的对象，就会把软引用的对象回收")])]),a._v(" "),r("h4",{attrs:{id:"用法-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用法-2"}},[a._v("#")]),a._v(" 用法")]),a._v(" "),r("div",{staticClass:"language-java line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SoftReference")]),r("span",{pre:!0,attrs:{class:"token generics"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" ref "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SoftReference")]),r("span",{pre:!0,attrs:{class:"token generics"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br")])]),r("h3",{attrs:{id:"弱引用-weakreference"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#弱引用-weakreference"}},[a._v("#")]),a._v(" 弱引用 WeakReference")]),a._v(" "),r("p",[a._v("发生垃圾回收时，被弱引用的对象和不可达的对象一样，会被垃圾回收")]),a._v(" "),r("h4",{attrs:{id:"用法-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#用法-3"}},[a._v("#")]),a._v(" 用法")]),a._v(" "),r("div",{staticClass:"language-java line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakReference")]),r("span",{pre:!0,attrs:{class:"token generics"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" ref "),r("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakReference")]),r("span",{pre:!0,attrs:{class:"token generics"}},[r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[a._v("1")]),r("br")])]),r("h1",{attrs:{id:"gc类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gc类型"}},[a._v("#")]),a._v(" GC类型")]),a._v(" "),r("h2",{attrs:{id:"发生区域划分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#发生区域划分"}},[a._v("#")]),a._v(" 发生区域划分")]),a._v(" "),r("h3",{attrs:{id:"minor-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#minor-gc"}},[a._v("#")]),a._v(" Minor GC")]),a._v(" "),r("p",[a._v("又称为Young GC，发生在堆区新生代")]),a._v(" "),r("blockquote",[r("p",[a._v("为什么Minor GC比Major GC快很多？")]),a._v(" "),r("ol",[r("li",[a._v("因为新生代中的"),r("strong",[a._v("大部分对象都是垃圾对象")]),a._v("，所以从GC Roots出发判断是否为垃圾对象的过程非常快")]),a._v(" "),r("li",[a._v("Minor GC采用复制-清除算法，通过额外的空间（Survivor To区），避免的内存整理，提高了处理速度")])])]),a._v(" "),r("h4",{attrs:{id:"触发条件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触发条件"}},[a._v("#")]),a._v(" 触发条件")]),a._v(" "),r("p",[a._v("当新生代"),r("strong",[a._v("Eden区的内存空间满")]),a._v("，或者不足以分配新的对象，则会触发Minor GC")]),a._v(" "),r("h4",{attrs:{id:"晋升老年代-promotion条件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#晋升老年代-promotion条件"}},[a._v("#")]),a._v(" 晋升老年代 promotion条件")]),a._v(" "),r("h5",{attrs:{id:"年龄-到达阈值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#年龄-到达阈值"}},[a._v("#")]),a._v(" “年龄”到达阈值")]),a._v(" "),r("p",[a._v("复制一次对象的年龄计数器+1，当年龄计数器到达阈值，会被晋升到老年代\n阈值设置参数："),r("code",[a._v("-XX:MaxTenuringThreshold=<N>")]),a._v(" 默认阈值为15")]),a._v(" "),r("h5",{attrs:{id:"动态对象年龄判断"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态对象年龄判断"}},[a._v("#")]),a._v(" 动态对象年龄判断")]),a._v(" "),r("p",[a._v("当YoungGC后，Survivor区中的存活对象的总大小超过Survivor区总内存大小的50%，会将“年龄”大于等于"),r("strong",[a._v("这批对象中最大年龄")]),a._v("的对象移到老年代")]),a._v(" "),r("h5",{attrs:{id:"超大对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#超大对象"}},[a._v("#")]),a._v(" 超大对象")]),a._v(" "),r("p",[a._v("当需要创建超大的对象，在新生代中没有足够的连续内存来存放")]),a._v(" "),r("p",[a._v("阈值设置参数："),r("code",[a._v("-XX:PretenureSizeThreshold")])]),a._v(" "),r("h5",{attrs:{id:"幸存-对象大小超过survivor容量"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#幸存-对象大小超过survivor容量"}},[a._v("#")]),a._v(" “幸存”对象大小超过Survivor容量")]),a._v(" "),r("p",[a._v("Minor GC后幸存的对象的总大小大于一个Survivor区的容量，这回把这些对象直接复制到老年代")]),a._v(" "),r("h3",{attrs:{id:"full-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#full-gc"}},[a._v("#")]),a._v(" Full GC")]),a._v(" "),r("p",[a._v("发生在新生代和老年代中的GC")]),a._v(" "),r("h4",{attrs:{id:"触发条件-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触发条件-2"}},[a._v("#")]),a._v(" 触发条件")]),a._v(" "),r("h5",{attrs:{id:"老年代空间不足"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#老年代空间不足"}},[a._v("#")]),a._v(" 老年代空间不足")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("创建一个大对象，eden区中空间不足，直接保存到老年代中，当老年代空间不足时候")])]),a._v(" "),r("li",[r("p",[a._v("Survivor对象晋升进入老年代，老年代空间不足")])]),a._v(" "),r("li",[r("p",[a._v("统计得到的Minor GC晋升到老年代的平均大小大于老年代的剩余空间")])])]),a._v(" "),r("h5",{attrs:{id:"g1中老年代占比达到阈值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1中老年代占比达到阈值"}},[a._v("#")]),a._v(" G1中老年代占比达到阈值")]),a._v(" "),r("p",[a._v("当老年代占用的Region达到总数的45%（由"),r("code",[a._v("-XX:InitatingHeapOccupancyPercent")]),a._v("设置，默认值为45%），会触发一次G1 Mixed GC（针对堆中所有Region的full GC）")]),a._v(" "),r("h1",{attrs:{id:"垃圾回收器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[a._v("#")]),a._v(" 垃圾回收器")]),a._v(" "),r("p",[a._v("无论是哪种垃圾回收器，在执行清除内存中的垃圾对象步骤时，都会停止系统程序的运行，不让系统程序执行任何代码逻辑，即“Stop the World”。")]),a._v(" "),r("p",[r("img",{attrs:{src:v(564),alt:""}})]),a._v(" "),r("p",[a._v("新生代")]),a._v(" "),r("ul",[r("li",[a._v("串行GC Serial")]),a._v(" "),r("li",[a._v("并行GC ParNew")]),a._v(" "),r("li",[a._v("并行回收GC Parallel Scavenge")])]),a._v(" "),r("p",[a._v("老年代")]),a._v(" "),r("ul",[r("li",[a._v("Serial Old")]),a._v(" "),r("li",[a._v("CMS")]),a._v(" "),r("li",[a._v("Parallel Old GC")])]),a._v(" "),r("p",[a._v("新生代和老年代垃圾搜集器组合")]),a._v(" "),r("p",[r("img",{attrs:{src:v(565),alt:"image-20200131223329897"}})]),a._v(" "),r("p",[r("code",[a._v("-XX:UseSerialGC")])]),a._v(" "),r("ul",[r("li",[a._v("年轻代：Serial")]),a._v(" "),r("li",[a._v("老年代：Serial Old")])]),a._v(" "),r("p",[r("code",[a._v("-XX:UseParNewGC")])]),a._v(" "),r("ul",[r("li",[a._v("年轻代：ParNew")]),a._v(" "),r("li",[a._v("老年代：Serial Old（默认配套的老年代收集器 不推荐）")])]),a._v(" "),r("p",[r("code",[a._v("-XX:UseConcMarkSweepGC")])]),a._v(" "),r("ul",[r("li",[a._v("年轻代：ParNew（默认关联的年轻代垃圾收集器）")]),a._v(" "),r("li",[a._v("老年代：CMS+Serial Old（如果CMS失败，会使用Serial Old进行垃圾回收）")])]),a._v(" "),r("p",[r("code",[a._v("-XX:UseParallelGC")])]),a._v(" "),r("ul",[r("li",[a._v("年轻代：Parallel Scavenge")]),a._v(" "),r("li",[a._v("老年代：Parallel Old")])]),a._v(" "),r("h2",{attrs:{id:"serial-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#serial-gc"}},[a._v("#")]),a._v(" Serial GC")]),a._v(" "),r("p",[r("code",[a._v("-XX:+UseSerialGC")])]),a._v(" "),r("p",[r("img",{attrs:{src:v(566),alt:"img"}})]),a._v(" "),r("p",[a._v("它是最古老的垃圾收集器，“Serial”体现在其收集工作是"),r("strong",[a._v("单线程")]),a._v("的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World” 状态。当然，其单线程设计也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下JVM的默认选项。")]),a._v(" "),r("p",[a._v("分为年轻代和老年代的实现：年轻代实现使用的是复制算法；老年代实现单独称作Serial Old，它采用了标记-整理（Mark-Compact）算法")]),a._v(" "),r("h2",{attrs:{id:"parnew-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#parnew-gc"}},[a._v("#")]),a._v(" ParNew GC")]),a._v(" "),r("p",[a._v("新生代GC实现")]),a._v(" "),r("p",[r("code",[a._v("-XX:+UseParNewGC")])]),a._v(" "),r("p",[a._v("是Serial GC的"),r("strong",[a._v("多线程")]),a._v("版本")]),a._v(" "),r("p",[a._v("默认对应的老年代收集器为Serial Old，不推荐使用。最常见的应用场景是配合老年代的CMS GC工作，利用多线程占用更多的计算资源来降低GC对系统带来的卡顿")]),a._v(" "),r("h2",{attrs:{id:"parallel-scavenge-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#parallel-scavenge-gc"}},[a._v("#")]),a._v(" Parallel Scavenge GC")]),a._v(" "),r("p",[a._v("新生代GC，绑定老年代使用 Parallel Old GC")]),a._v(" "),r("p",[r("code",[a._v("-XX:UseParallelGC")])]),a._v(" "),r("p",[a._v("ParNew的优化版本，添加了2个新特性")]),a._v(" "),r("ul",[r("li",[a._v("可控的吞吐量："),r("code",[a._v("thoughtput=用户线程执行时间/(用户线程执行时间+垃圾收集时间)")])]),a._v(" "),r("li",[a._v("自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，动态调节以提供最合适的停顿时间（"),r("code",[a._v("-XX:MaxGCPauseMills")]),a._v("）和最大吞吐量")])]),a._v(" "),r("h2",{attrs:{id:"cms-concurrent-mark-sweep-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#cms-concurrent-mark-sweep-gc"}},[a._v("#")]),a._v(" CMS（Concurrent Mark Sweep） GC")]),a._v(" "),r("p",[a._v("老年代GC算法")]),a._v(" "),r("blockquote",[r("p",[a._v("特点")]),a._v(" "),r("ul",[r("li",[a._v("标记-清除 有是碎片")]),a._v(" "),r("li",[a._v('减少"Stop the World"')])])]),a._v(" "),r("p",[r("code",[a._v("-XX:+UseConcMarkSweepGC")])]),a._v(" "),r("p",[a._v("设计目标是"),r("strong",[a._v("尽量减少停顿时间")]),a._v("，这一点对于Web等反应时间敏感的应用非常重要\n但是，CMS基于"),r("strong",[a._v("标记-清除")]),a._v("（Mark-Sweep）算法，"),r("strong",[a._v("存在着内存碎片化问题")]),a._v("，为了避免碎片化导致频繁的GC，CMS GC会在垃圾回收完成后，进行一次“Stop the World”，进行内存整理。")]),a._v(" "),r("blockquote",[r("p",[a._v("另外，强调了并发（Concurrent），垃圾回收线程与系统工作线程"),r("strong",[a._v("尽量同时执行")]),a._v("，所以CMS会占用更多CPU资源，并和用户线程争抢CPU资源。")])]),a._v(" "),r("h3",{attrs:{id:"执行过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行过程"}},[a._v("#")]),a._v(" 执行过程")]),a._v(" "),r("p",[r("img",{attrs:{src:v(567),alt:"img"}})]),a._v(" "),r("h4",{attrs:{id:"初始标记-initial-mark"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#初始标记-initial-mark"}},[a._v("#")]),a._v(" 初始标记 Initial Mark")]),a._v(" "),r("p",[a._v('会让系统线程全部停止，进入"Stop the World"，标记出所有GC Roots'),r("strong",[a._v("直接引用")]),a._v("的对象")]),a._v(" "),r("h4",{attrs:{id:"并发标记-concurrent-mark"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并发标记-concurrent-mark"}},[a._v("#")]),a._v(" 并发标记 Concurrent Mark")]),a._v(" "),r("p",[a._v('退出"Stop the World"，让系统工作线程继续开始工作，对所有的对象进行GC Roots跟踪，找到老年代中所有被GC Roots引用的对象')]),a._v(" "),r("p",[a._v("在此过程中可能会创建新的存活对象，也可能会有部分存货对象失去引用，变成垃圾对象。垃圾回收线程会尽量的对已有的对象进行"),r("strong",[a._v("GC Roots追踪")])]),a._v(" "),r("h4",{attrs:{id:"重新标记-remark"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重新标记-remark"}},[a._v("#")]),a._v(" 重新标记 Remark")]),a._v(" "),r("p",[a._v('再次进入"Stop the World"，对并发标记阶段中系统运行'),r("strong",[a._v("变动过的少数对象")]),a._v("进行标记")]),a._v(" "),r("h4",{attrs:{id:"并发清理-concurrent-mark"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#并发清理-concurrent-mark"}},[a._v("#")]),a._v(" 并发清理 Concurrent Mark")]),a._v(" "),r("p",[a._v('退出"Stop the World"，开始清理被标记为垃圾的对象')]),a._v(" "),r("h5",{attrs:{id:"concurrent-mode-failure"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-mode-failure"}},[a._v("#")]),a._v(" Concurrent Mode Failure")]),a._v(" "),r("p",[r("code",[a._v("-XX:CMSInitiatingOccupancyFaction")]),a._v(" 默认为92% 开启执行CMS GC的")]),a._v(" "),r("p",[a._v("为并发标记过程中可能新加入老年代的对象预留空间")]),a._v(" "),r("p",[a._v("当"),r("strong",[a._v("并发清理")]),a._v("期间，预留的空间不足以存放下要进入老年代的对象，引发“Concurrent Mode Failure”。会放弃CMS GC，改用Serial Old GC，“Stop the World”之后重新单线程执行一次垃圾回收过程")]),a._v(" "),r("h4",{attrs:{id:"内存整理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存整理"}},[a._v("#")]),a._v(" 内存整理")]),a._v(" "),r("p",[a._v("CMS GC采用标记-清除算法，会产生内存碎片。为了防止积累的内存碎片导致Full GC，会定时在CMS GC完成后，对老年代进行整理")]),a._v(" "),r("p",[a._v("使用"),r("code",[a._v("-XX:UseCMSCompactAtFullCollection")]),a._v("控制是否开启内存整理，默认情况下开启")]),a._v(" "),r("p",[a._v("使用"),r("code",[a._v("-XX:CMSFullGCsBeforeCompaction")]),a._v("控制每执行多少次Full GC 执行一次内存整理。默认是0，表示每次Full GC之后都会进行一次内存整理。")]),a._v(" "),r("h2",{attrs:{id:"parrallel-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#parrallel-gc"}},[a._v("#")]),a._v(" Parrallel GC")]),a._v(" "),r("p",[r("img",{attrs:{src:v(568),alt:"img"}})]),a._v(" "),r("p",[a._v("新生代和老年代")]),a._v(" "),r("p",[r("code",[a._v("-XX:+UseParallelGC")])]),a._v(" "),r("p",[a._v("在早期JDK 8等版本中，它是server模式JVM的默认GC选择，也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂的多，其特点是"),r("strong",[a._v("新生代和老年代GC都是并行进行的")]),a._v("，在常见的服务器环境中更加高效。")]),a._v(" "),r("h2",{attrs:{id:"g1-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#g1-gc"}},[a._v("#")]),a._v(" G1 GC")]),a._v(" "),r("p",[r("img",{attrs:{src:v(569),alt:"img"}})]),a._v(" "),r("p",[a._v("新生代和老年代")]),a._v(" "),r("p",[r("code",[a._v("-XX:+UseG1GC")])]),a._v(" "),r("p",[a._v("应用于多处理器和大内存环境，一种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。G1可以"),r("strong",[a._v("直观的设定停顿时间的目标")]),a._v("（最多可以让系统停顿的时长，默认为200ms，可以通过"),r("code",[a._v("-XX:MaxGCPauseMills")]),a._v("设置）")]),a._v(" "),r("p",[a._v("相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。")]),a._v(" "),r("h3",{attrs:{id:"原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[a._v("#")]),a._v(" 原理")]),a._v(" "),r("h4",{attrs:{id:"分制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分制"}},[a._v("#")]),a._v(" 分制")]),a._v(" "),r("p",[a._v("化整为零的思路，将堆内存拆分成多个大小相等的"),r("strong",[a._v("Region")]),a._v("，对每一个Region进行跟踪，知道对每一个Region的回收价值。")]),a._v(" "),r("h4",{attrs:{id:"region"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#region"}},[a._v("#")]),a._v(" Region")]),a._v(" "),r("p",[a._v("G1收集器将堆内存拆分成多个大小相等的"),r("strong",[a._v("Region")])]),a._v(" "),r("p",[a._v("Region可以被分配给Eden、Survivor、老年代和大对象专用区，JVM会动态的将Region按需分配给这四种用途")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("Eden")])]),a._v(" "),r("li",[r("p",[a._v("Survivor")])]),a._v(" "),r("li",[r("p",[a._v("Old")])]),a._v(" "),r("li",[r("p",[a._v("Humongous")]),a._v(" "),r("p",[a._v("多个"),r("strong",[a._v("连续")]),a._v("的region来存放一个大对象")])])]),a._v(" "),r("h4",{attrs:{id:"内存分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存分配"}},[a._v("#")]),a._v(" 内存分配")]),a._v(" "),r("h5",{attrs:{id:"region内存大小"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#region内存大小"}},[a._v("#")]),a._v(" Region内存大小")]),a._v(" "),r("p",[a._v("设置为G1回收器，默认配置下，每个Region的大小会根据分配堆内存的大小决定，将堆内存平均分成2048个Region")]),a._v(" "),r("p",[a._v("或者可以通过"),r("code",[a._v("-XX:G1HeapRegionSize")]),a._v("来指定每个Region的大小")]),a._v(" "),r("h5",{attrs:{id:"新生代内存分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#新生代内存分配"}},[a._v("#")]),a._v(" 新生代内存分配")]),a._v(" "),r("p",[a._v("G1收集器的内存中"),r("strong",[a._v("逻辑上")]),a._v("划分了新生代（也有Eden区和Survivor区的概念，比例默认依然是8:1，比如新生代有100个Region，那么Eden占80个，两个Survivor占10个）和老年区")]),a._v(" "),r("p",[a._v("但G1中的内存分配是动态的。初始状态，新生代的region占总体的5%，可以通过"),r("code",[a._v("-XX:G1NewSizePercent")]),a._v("来设置新生代的初始占比。")]),a._v(" "),r("p",[a._v("在系统的运行过程中，JVM会不停的给新生代增加更多的Region，但是新生代的占比"),r("strong",[a._v("不超过60%")]),a._v("，可以通过"),r("code",[a._v("-XX:G1MaxNewSizePercent")])]),a._v(" "),r("h5",{attrs:{id:"老年代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#老年代"}},[a._v("#")]),a._v(" 老年代")]),a._v(" "),r("p",[a._v("进入老年代的条件")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("对象存活代数（年纪）超过阈值")])]),a._v(" "),r("li",[r("p",[a._v("动态年龄判定规则：某次新生代GC后，存活对象中某个存活代数的对象占Survivor中的50%，用这个代数来替代原来的阈值")])]),a._v(" "),r("li",[r("p",[a._v("大对象不直接进入老年代，而是G1提供专门的Region来存放大对象")]),a._v(" "),r("p",[a._v("当对象的大小大于Region大小的50%，会被放入大对象专用的Region中，如果对象太大，可能会横跨多个Region来存放")])])]),a._v(" "),r("h4",{attrs:{id:"动态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态"}},[a._v("#")]),a._v(" 动态")]),a._v(" "),r("p",[a._v("垃圾回收时不区分年轻代和老年代。G1中堆内存的年轻代和老年代只是逻辑上的概念（某一个region可能现在是用来存放新生代的对象，一段时间之后，被用来存放老年代的对象），新生代不再是固定的大小")]),a._v(" "),r("h4",{attrs:{id:"回收价值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#回收价值"}},[a._v("#")]),a._v(" 回收价值")]),a._v(" "),r("p",[a._v("G1收集器会追踪每一个Region中需要回收的对象大小，以及对这个region进行垃圾回收预计需要多长时间")]),a._v(" "),r("ul",[r("li",[a._v("可回收内存大小")]),a._v(" "),r("li",[a._v("需要花费的时间")])]),a._v(" "),r("p",[a._v("最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象")]),a._v(" "),r("h4",{attrs:{id:"复制算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[a._v("#")]),a._v(" 复制算法")]),a._v(" "),r("p",[a._v("新生代GC和混合GC都是使用"),r("strong",[a._v("复制算法")]),a._v("，以region作为最小单位")]),a._v(" "),r("h3",{attrs:{id:"gc机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gc机制"}},[a._v("#")]),a._v(" GC机制")]),a._v(" "),r("h4",{attrs:{id:"新生代-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#新生代-gc"}},[a._v("#")]),a._v(" 新生代 GC")]),a._v(" "),r("p",[a._v("与其他垃圾收集器一样，使用Eden区和Survivor区的复制算法进行垃圾回收，只是Eden和Survivor的是由Region组成，大小根据分配动态变化")]),a._v(" "),r("h4",{attrs:{id:"mixed-gc"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#mixed-gc"}},[a._v("#")]),a._v(" Mixed GC")]),a._v(" "),r("p",[r("strong",[a._v("不区分新生代和老年代")]),a._v(" 对堆内存中的所有Region都进行垃圾回收")]),a._v(" "),r("p",[a._v("将回收的Region里的存活对象复制到其他空闲的Region，然后将在回收的Region清空，成为空闲的Region")]),a._v(" "),r("p",[a._v("根据计算每个Region中的存活对象数量，存活对象的占比，结合执行垃圾回收的预期性能和效率（"),r("strong",[a._v("回收价值")]),a._v("），执行垃圾回收")]),a._v(" "),r("p",[a._v("垃圾回收时会"),r("strong",[a._v("停止系统程序")]),a._v("。如果在规定的时间内无法完整的垃圾回收，选择部分Region进行回收，"),r("strong",[a._v("分多次")]),a._v("进行垃圾回收，将单位时间内的停顿时间控制在设定范围内")]),a._v(" "),r("p",[a._v("考虑预设GC停顿时间，"),r("strong",[a._v("挑选一部分")]),a._v("Region进行垃圾回收，保证垃圾回收的停顿时间不超过预设时间")]),a._v(" "),r("h5",{attrs:{id:"执行流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#执行流程"}},[a._v("#")]),a._v(" 执行流程")]),a._v(" "),r("p",[r("img",{attrs:{src:v(570),alt:"image-20200201122500398"}})]),a._v(" "),r("p",[a._v("当老年代占据了堆内存的占比达到"),r("code",[a._v("InitatingHeapOccupancyPercent")]),a._v("时触发GC")]),a._v(" "),r("blockquote",[r("p",[a._v("类似于CMS GC，同样使用对线程进行垃圾收集，是CMS的分制版本，并且不会产生内存碎片")])]),a._v(" "),r("ul",[r("li",[r("p",[a._v("初始标记")]),a._v(" "),r("p",[a._v("先停止系统程序的运行，然后根据GC Roots（线程栈内存中的局部变量引用以及方法区中的静态变量引用）标记出被GC Roots"),r("strong",[a._v("直接引用")]),a._v("的对象为存活对象。")])]),a._v(" "),r("li",[r("p",[a._v("并发标记")]),a._v(" "),r("p",[a._v("这个阶段允许程序允许，同时进行“sub” GC Roots"),r("strong",[a._v("跟踪")]),a._v("，将初始标记的存活对象所引用的对象也标记为存活对象")])]),a._v(" "),r("li",[r("p",[a._v("最终标记")]),a._v(" "),r("p",[a._v("停止系统程序的运行，根据并发标记阶段记录的那些对象修改，最终标记有哪些存活对象，那些是垃圾对象")])]),a._v(" "),r("li",[r("p",[a._v("混合回收")]),a._v(" "),r("p",[a._v("根据当前内存情况和暂停时间预期，分多次进行Mixed GC，每次对部分Region进行回收")])]),a._v(" "),r("li",[r("p",[a._v("回收失败 Full GC")]),a._v(" "),r("p",[a._v("使用复制算法进行垃圾回收时，如果没有足够空闲的Region来存放GC存活的对象，就表示回收失败。会采用单线程进行标记、清理和压缩整理，来清理出空闲的Region")])])]),a._v(" "),r("h3",{attrs:{id:"相关参数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#相关参数"}},[a._v("#")]),a._v(" 相关参数")]),a._v(" "),r("ul",[r("li",[r("p",[r("code",[a._v("-Xmx")]),a._v(" "),r("code",[a._v("-Xms")])]),a._v(" "),r("p",[a._v("每个Region大小与heap的总大小相关")])]),a._v(" "),r("li",[r("p",[r("code",[a._v("-XX:G1HeapRegionSize")])]),a._v(" "),r("p",[a._v("设置Region的大小")])]),a._v(" "),r("li",[r("p",[r("code",[a._v("-XX:MaxGCPauseMills")])]),a._v(" "),r("p",[a._v("设置每次触发一次GC（新生代GC和混合GC）导致的系统停顿（stop the world）的时长，默认值为200毫秒")]),a._v(" "),r("blockquote",[r("p",[a._v("平衡GC的频率和系统停顿时间")]),a._v(" "),r("p",[a._v("频率太低，会导致一次GC")])])]),a._v(" "),r("li",[r("p",[r("code",[a._v("-XX:G1MaxNewSizePercent")])]),a._v(" "),r("p",[a._v("设置触发新生代垃圾回收的阈值，默认值为60%")])]),a._v(" "),r("li",[r("p",[r("code",[a._v("-XX:InitatingHeapOccupancyPercent")])]),a._v(" "),r("p",[a._v("设置触发混合垃圾回收的阈值，默认值为45%")]),a._v(" "),r("p",[a._v("当"),r("strong",[a._v("老年代")]),a._v("占据了堆内存45%的Region的时候，会尝试触发一次Mixed GC")])]),a._v(" "),r("li",[r("p",[r("code",[a._v("-XX:G1MixedGCCountTarget")])]),a._v(" "),r("p",[a._v("一次G1 GC最后阶段的混合回收的次数，默认为8次")]),a._v(" "),r("blockquote",[r("p",[a._v("一次G1 GC可以持续好几个小时")])])]),a._v(" "),r("li",[r("p",[r("code",[a._v("-XX:G1HeapWastePercent")])]),a._v(" "),r("p",[a._v("在Mixed GC过程中，会不断的空出新的Region，空闲的Region达到堆内存的5%（默认值），就会停止本次混合垃圾回收")])]),a._v(" "),r("li",[r("p",[r("code",[a._v("-XX:G1MixedGCLiveThresholdPercent")])]),a._v(" "),r("p",[a._v("默认值为85%，表示确定待回收的Region时，必须满足存活的对象低于整个Region大小的85%")]),a._v(" "),r("p",[a._v("可以理解成，用来衡量Region的"),r("strong",[a._v("回收价值")])])])]),a._v(" "),r("h1",{attrs:{id:"gc算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gc算法"}},[a._v("#")]),a._v(" GC算法")]),a._v(" "),r("h2",{attrs:{id:"复制算法-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复制算法-2"}},[a._v("#")]),a._v(" 复制算法")]),a._v(" "),r("blockquote",[r("p",[a._v("优点：避免内存碎片化")]),a._v(" "),r("p",[a._v("缺点：进行复制，既要提前预留内存空间，有一定的"),r("strong",[a._v("空间浪费")])])]),a._v(" "),r("p",[a._v("新生代GC基于复制算法\n将Eden和Survivor0（from区域）中存活的对象复制到to区域（survivor1），拷贝过程中将对象顺序放置，就可以避免内存碎片化，提高内存的利用率")]),a._v(" "),r("h2",{attrs:{id:"标记-整理-压缩-算法-mark-compact"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理-压缩-算法-mark-compact"}},[a._v("#")]),a._v(" 标记-整理(压缩)算法 Mark-Compact")]),a._v(" "),r("blockquote",[r("p",[a._v("老年代GC算法")]),a._v(" "),r("p",[a._v("优点：避免内存碎片化")]),a._v(" "),r("p",[a._v("缺点：效率不高")])]),a._v(" "),r("p",[a._v("类似于标记-清除，但为避免内存碎片化，它会在清理过程中"),r("strong",[a._v("将对象移动")]),a._v("，以确保移动后的对象占用连续的内存空间")]),a._v(" "),r("h2",{attrs:{id:"标记-清除算法-mark-sweep"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除算法-mark-sweep"}},[a._v("#")]),a._v(" 标记-清除算法 Mark-Sweep")]),a._v(" "),r("blockquote",[r("p",[a._v("老年代GC算法")]),a._v(" "),r("p",[a._v("优点：效率较高")]),a._v(" "),r("p",[a._v("缺点：内存碎片化")])]),a._v(" "),r("p",[a._v("首先进行标记工作，标识出所有要回收的对象，然后进行清除。")]),a._v(" "),r("blockquote",[r("p",[a._v("这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现Full GC，暂停时间可能根本无法接受")])]),a._v(" "),r("h1",{attrs:{id:"gc执行流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#gc执行流程"}},[a._v("#")]),a._v(" GC执行流程")]),a._v(" "),r("p",[r("img",{attrs:{src:v(571),alt:""}})]),a._v(" "),r("h3",{attrs:{id:"内存担保机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存担保机制"}},[a._v("#")]),a._v(" 内存担保机制")]),a._v(" "),r("p",[a._v("在MinorGC执行之前，会检查老年代"),r("strong",[a._v("最大可用连续空间")]),a._v("是否大于新生代中所有对象占用的空间大小")]),a._v(" "),r("p",[a._v("如果检查通过，则这次GC安全，执行Minor GC；")]),a._v(" "),r("p",[a._v("如果不通过")]),a._v(" "),r("p",[a._v("使用老年代的空间为Minor GC进行担保")]),a._v(" "),r("p",[a._v("Minor GC在极端条件下，没有对象被回收，全部升入老年代，不会出现OOM异常")]),a._v(" "),r("p",[a._v("如果不通过则会查看HandlePromotionFailure设置值是否允许担保失败")]),a._v(" "),r("ul",[r("li",[r("p",[a._v("开启内存担保 默认  "),r("code",[a._v("-XX:+HandlePromotionFailure")])]),a._v(" "),r("p",[a._v("担保失败 直接出发Full GC")]),a._v(" "),r("p",[a._v("是一种严格的内存回收策略，会提高Full GC的频率 提高负载")])]),a._v(" "),r("li",[r("p",[a._v("不允许担保失败  "),r("code",[a._v("-XX:-HandlePromotionFailure")])]),a._v(" "),r("p",[a._v("只会进行MinorGC，此时可以"),r("strong",[a._v("容忍内存分配失败")])])])]),a._v(" "),r("h3",{attrs:{id:"动态年龄判定"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#动态年龄判定"}},[a._v("#")]),a._v(" 动态年龄判定")]),a._v(" "),r("p",[a._v("某次GC过后，JVM发现Survivor区中存活的所有对象占用大小大于Survivor区域的50%时，会统计所有“年龄”对象所占空间大小，按年龄从小到大开始"),r("strong",[a._v("累加")]),a._v("，当累加的大小超过50%，会将当前计入累加的最大年龄以及大于该年龄的对象移至老年代")])])}),[],!1,null,null,null);t.default=e.exports}}]);