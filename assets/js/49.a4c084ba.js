(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{658:function(t,v,_){"use strict";_.r(v);var a=_(21),s=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"cache-aside-pattern"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-aside-pattern"}},[t._v("#")]),t._v(" Cache Aside Pattern")]),t._v(" "),_("p",[t._v("查询接口添加缓存的基本逻辑")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("查询时先检查缓存数据库中是否有数据")]),t._v(" "),_("ul",[_("li",[t._v("如果有直接返回")]),t._v(" "),_("li",[t._v("如果没有 查询数据库并将数据存入缓存数据库 再返回")])])]),t._v(" "),_("li",[_("p",[t._v("当数据库中的数据发送改变后，会将缓存中对应的数据失效")]),t._v(" "),_("p",[t._v("懒加载思想 下一次查询时再从数据库中加载")])])]),t._v(" "),_("h2",{attrs:{id:"数据不一致场景-解决方案演进"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据不一致场景-解决方案演进"}},[t._v("#")]),t._v(" 数据不一致场景&解决方案演进")]),t._v(" "),_("h3",{attrs:{id:"先更新数据库-再删除缓存【脏读】"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#先更新数据库-再删除缓存【脏读】"}},[t._v("#")]),t._v(" 先更新数据库 再删除缓存【脏读】")]),t._v(" "),_("p",[t._v("因为数据库操作和缓存操作，分别对两个中间件进行操作，无法构成一个本地事务。")]),t._v(" "),_("p",[t._v("可能出现修改数据库成功，但是删除缓存失败（网络原因）。导致缓存中的”老数据“被客户端访问，直到下一次更新操作成功删除缓存，客户端才能访问到正确的数据。")]),t._v(" "),_("h3",{attrs:{id:"先删除缓存-再更新数据库【并发脏读】"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#先删除缓存-再更新数据库【并发脏读】"}},[t._v("#")]),t._v(" 先删除缓存 再更新数据库【并发脏读】")]),t._v(" "),_("p",[t._v("可以避免"),_("strong",[t._v("低并发场景下的脏读")]),t._v("的问题：先删除缓存，如果更新数据库失败，当下一次读请求时，也会访问数据库获取正确的数据。")]),t._v(" "),_("p",[t._v("在并发读写的场景下，还是会出现脏读")]),t._v(" "),_("p",[t._v("在对一个资源的更新操作执行的过程中，删除了缓存，但还没更新数据库")]),t._v(" "),_("p",[t._v("另一个"),_("strong",[t._v("相同资源")]),t._v("的读请求，发现缓存为空，就会重新读取数据库中"),_("strong",[t._v("还未更新的记录")]),t._v("，并存到缓存中")]),t._v(" "),_("p",[t._v("后面的读请求还是读取的旧数据")]),t._v(" "),_("h3",{attrs:{id:"根据资源标识串行化执行更新和查询【最终方案】"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#根据资源标识串行化执行更新和查询【最终方案】"}},[t._v("#")]),t._v(" 根据资源标识串行化执行更新和查询【最终方案】")]),t._v(" "),_("p",[t._v("上述出现并发脏读的原因是"),_("strong",[t._v("同一个资源")]),t._v("在同一时间"),_("strong",[t._v("并发的进行更新和查询操作")])]),t._v(" "),_("p",[t._v("解决的方式是将同一资源的更新和查询操作串行化，来保证不会出现并发脏读的情况。")]),t._v(" "),_("p",[t._v("实现思路是将更新和查询操作封装成任务，根据资源的唯一标识hash到JVM中对应的阻塞队列中，每个阻塞队列对应一个线程死循环消费任务队列中的任务")])])}),[],!1,null,null,null);v.default=s.exports}}]);