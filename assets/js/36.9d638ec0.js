(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{631:function(t,s,a){"use strict";a.r(s);var n=a(21),r=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"思维导图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#思维导图"}},[t._v("#")]),t._v(" 思维导图")]),t._v(" "),a("iframe",{staticStyle:{display:"block",width:"825px",height:"500px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/612adffd6376895796313445"}}),t._v(" "),a("p",[t._v("递归与循环迭代并列，作为算法中解决"),a("strong",[t._v("大规模问题")]),t._v("的手段。")]),t._v(" "),a("h1",{attrs:{id:"与迭代的比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#与迭代的比较"}},[t._v("#")]),t._v(" 与迭代的比较")]),t._v(" "),a("h2",{attrs:{id:"进度记录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进度记录"}},[t._v("#")]),t._v(" 进度记录")]),t._v(" "),a("ul",[a("li",[t._v("迭代\n通过修改循环外部的数据结构来记录问题解决的进度，如for循环的"),a("code",[t._v("i")])]),t._v(" "),a("li",[t._v("递归\n通过"),a("strong",[t._v("方法调用栈")]),t._v("来保存进度")])]),t._v(" "),a("h2",{attrs:{id:"缺点-额外开销"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点-额外开销"}},[t._v("#")]),t._v(" 缺点：额外开销")]),t._v(" "),a("p",[t._v("递归会带来额外的开销：")]),t._v(" "),a("ul",[a("li",[t._v("方法调用的开销")]),t._v(" "),a("li",[t._v("方法调用栈的内存开销")])]),t._v(" "),a("h2",{attrs:{id:"优点-更复杂问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优点-更复杂问题"}},[t._v("#")]),t._v(" 优点：更复杂问题")]),t._v(" "),a("p",[t._v("相较于循环迭代，可以描述更复杂的逻辑")]),t._v(" "),a("h2",{attrs:{id:"衡量指标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#衡量指标"}},[t._v("#")]),t._v(" 衡量指标")]),t._v(" "),a("ul",[a("li",[t._v("迭代\n使用"),a("strong",[t._v("实践复杂度")]),t._v("和"),a("strong",[t._v("空间复杂度")]),t._v("来描述一个基于迭代的算法的性能")]),t._v(" "),a("li",[t._v("递归\n使用递归深度来描述一个机遇递归的算法的性能")])]),t._v(" "),a("h1",{attrs:{id:"求解原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#求解原则"}},[t._v("#")]),t._v(" 求解原则")]),t._v(" "),a("p",[t._v("递归的本质是将原问题转化为一个更小规模的问题，然后再将这个规模更小的问题"),a("strong",[t._v("使用相同的方法")]),t._v("继续分解，直到分解到无法在分解")]),t._v(" "),a("p",[t._v("求解思路通常分为两步")]),t._v(" "),a("p",[t._v("以递归求和数组为例")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1.问题分解")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" l"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("l "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3. 元问题求解")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("l"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("l "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2. 问题回归")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])]),a("h2",{attrs:{id:"_1-问题分解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-问题分解"}},[t._v("#")]),t._v(" 1.问题分解")]),t._v(" "),a("p",[t._v("定义递归函数的语义：递归函数的目的是为了"),a("strong",[t._v("将问题的规模缩小")]),t._v("，并将更小规模的问题作为参数子再传给这个递归函数。")]),t._v(" "),a("p",[t._v("本质上是定义函数中"),a("code",[t._v("return")]),t._v("后面表达式")]),t._v(" "),a("p",[t._v("需要满足的原则是**"),a("code",[t._v("return")]),t._v("后面（广义上的，比一定是"),a("code",[t._v("return")]),t._v("后面那一行）表达式的语义与整个函数的语义等价**")]),t._v(" "),a("p",[t._v("以上述求和递归算法为例")]),t._v(" "),a("blockquote",[a("h4",{attrs:{id:"sum问题拆解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sum问题拆解"}},[t._v("#")]),t._v(" sum问题拆解")]),t._v(" "),a("p",[t._v("sum函数的核心实现思："),a("code",[t._v("l")]),t._v("到数组末尾元素的和 = "),a("code",[t._v("arr[l]")]),t._v("的值 加上 "),a("code",[t._v("l + 1")]),t._v("到数组末尾元素的和")]),t._v(" "),a("p",[t._v("这个"),a("strong",[t._v("等式")]),t._v("将sum函数拆解成一个常量和另一个更小规模的问题")])]),t._v(" "),a("h2",{attrs:{id:"_2-问题回归"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-问题回归"}},[t._v("#")]),t._v(" 2.问题回归")]),t._v(" "),a("p",[t._v("递归函数的定义中，返回值是必要的。通过返回值的赋值操作，可以组装成上一层（更大规模的）问题，实现"),a("strong",[t._v("问题的回归")]),t._v("，这也是递归这个名字的由来。")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("········· "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("l"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n····················\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("l"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("arr "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("l "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])]),a("h2",{attrs:{id:"_3-元问题求解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-元问题求解"}},[t._v("#")]),t._v(" 3.元问题求解")]),t._v(" "),a("p",[t._v("当问题缩小到无法再缩小，可以通过简单的表达式，得到“显而易见”的结果。\n此时调用方法栈达到最深，最内层方法返回（方法栈顶的栈桢出栈）\n直到最外层的方法返回，一层层“反向分解”，最终得到问题的答案")]),t._v(" "),a("blockquote",[a("p",[t._v("类似于循环迭代中的“退出条件”")]),t._v(" "),a("p",[t._v("在sum函数的例子中，数组规模缩小到没有元素，求和的结果就是0")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("l "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" arr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3. 元问题求解")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br")])])])])}),[],!1,null,null,null);s.default=r.exports}}]);