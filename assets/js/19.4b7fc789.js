(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{581:function(_,e,a){_.exports=a.p+"assets/img/733013-20180508182756285-1761418702.a5f37c99.png"},582:function(_,e,a){_.exports=a.p+"assets/img/733013-20180508184303598-1449455496.093efcb5.png"},583:function(_,e,a){_.exports=a.p+"assets/img/image-20210909153943018.6508eb1e.png"},584:function(_,e,a){_.exports=a.p+"assets/img/image-20210909223512241.d981917a.png"},655:function(_,e,a){"use strict";a.r(e);var r=a(21),t=Object(r.a)({},(function(){var _=this,e=_.$createElement,r=_._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h1",{attrs:{id:"综述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#综述"}},[_._v("#")]),_._v(" 综述")]),_._v(" "),r("p",[_._v("InnoDB使用**读写缓存（Buffer Pool）"),r("strong",[_._v("和")]),_._v("WAL机制（Write-Ahead Logging）**来提高读写操作的效率")]),_._v(" "),r("ul",[r("li",[_._v("读写缓存\nInnoDB会在Buffer Pool中缓存被访问的数据页，来提高客户端的读写效率")]),_._v(" "),r("li",[_._v("WAL机制\n通过顺序写入日志文件（Redo Log和binlog），来保证更新操作的持久性，同时提高写入的效率（顺序读写的效率大于随机读）")])]),_._v(" "),r("h2",{attrs:{id:"整体流程图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#整体流程图"}},[_._v("#")]),_._v(" 整体流程图")]),_._v(" "),r("iframe",{staticStyle:{display:"block",width:"1000px",height:"545px"},attrs:{id:"embed_dom",name:"embed_dom",frameborder:"0",src:"https://www.processon.com/embed/611392e57d9c0806e4a72651"}}),_._v(" "),r("h1",{attrs:{id:"正文"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#正文"}},[_._v("#")]),_._v(" 正文")]),_._v(" "),r("h2",{attrs:{id:"wal机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#wal机制"}},[_._v("#")]),_._v(" WAL机制")]),_._v(" "),r("h3",{attrs:{id:"redo-log-重做日志"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redo-log-重做日志"}},[_._v("#")]),_._v(" Redo Log 重做日志")]),_._v(" "),r("p",[_._v("Redo log用来保证InnoDB数据的持久性：记录了对数据页的改动。")]),_._v(" "),r("blockquote",[r("p",[_._v("session_id + date + 数据行修改信息")]),_._v(" "),r("ul",[r("li",[_._v("session_id：执行操作的session_id")]),_._v(" "),r("li",[_._v("date：执行时间戳")]),_._v(" "),r("li",[_._v("数据行修改信息\n"),r("strong",[_._v("表空间号+数据页号+偏移量+修改几个字节的值+具体的值")])])])]),_._v(" "),r("p",[_._v("当更新操作被写入到redo log，InnoDB就认为持久化已完成，InnoDB维护了一套机制来保证数据读写的一致性。")]),_._v(" "),r("p",[_._v("崩溃恢复和缓存脏页刷盘都依赖redo log。")]),_._v(" "),r("h4",{attrs:{id:"数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[_._v("#")]),_._v(" 数据结构")]),_._v(" "),r("h5",{attrs:{id:"数据块"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据块"}},[_._v("#")]),_._v(" 数据块")]),_._v(" "),r("p",[r("img",{attrs:{src:a(581),alt:"img"}})]),_._v(" "),r("p",[_._v("redo log"),r("strong",[_._v("以块为单位")]),_._v("进行存储的，每个块占512字节，这称为redo log block。")]),_._v(" "),r("p",[_._v("每一个日志块分为三个部分")]),_._v(" "),r("ul",[r("li",[_._v("日志块头 12bits\n"),r("ul",[r("li",[_._v("log_block_hdr_no：(4bits)\n该日志块在redo log buffer中的位置ID")]),_._v(" "),r("li",[_._v("log_block_hdr_data_len：(2bits)\n该log block中已记录的log大小。写满该log block时为0x200，表示512字节")]),_._v(" "),r("li",[_._v("log_block_first_rec_group：(2bits)\n该log block中第一个log的开始偏移位置")]),_._v(" "),r("li",[_._v("lock_block_checkpoint_no：(4bits)\n写入检查点信息的位置")])])]),_._v(" "),r("li",[_._v("日志主体 492bits")]),_._v(" "),r("li",[_._v("日志块尾 8bits\n"),r("ul",[r("li",[_._v("log_block_trl_no 标记日志块结尾\n该值和块头的 log_block_hdr_no 相等")])])])]),_._v(" "),r("h5",{attrs:{id:"log-body"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#log-body"}},[_._v("#")]),_._v(" log body")]),_._v(" "),r("p",[_._v("日志体中，由一行行具体的操作记录组成")]),_._v(" "),r("ul",[r("li",[_._v("redo_log_type 1bit\n表示redo log的日志类型")]),_._v(" "),r("li",[_._v("space 表示表空间ID")]),_._v(" "),r("li",[_._v("page_no 表示数据页的标识（偏移量）")]),_._v(" "),r("li",[_._v("redo_log_body 表示每天日志的数据部分\n恢复时会调用相应的函数进行解析\n增删改对应不同的数据结构")])]),_._v(" "),r("p",[r("img",{attrs:{src:a(582),alt:"img"}})]),_._v(" "),r("h4",{attrs:{id:"lsn-日志逻辑序列号-log-sequence-number"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lsn-日志逻辑序列号-log-sequence-number"}},[_._v("#")]),_._v(" LSN 日志逻辑序列号 log sequence number")]),_._v(" "),r("p",[_._v("LSN是一个64位整型，全局维护一个不断增加的序列号。"),r("strong",[_._v("LSN实际上对应日志文件的偏移量")]),_._v("：新增日志的LSN＝当前LSN + 写入的日志大小。")]),_._v(" "),r("p",[_._v("通过"),r("code",[_._v("show engine innodb stauts")]),_._v("可以查看当前的LSN")]),_._v(" "),r("p",[_._v("LSN作为redo log每个数据操作的"),r("strong",[_._v("全局唯一标识")]),_._v("。执行修改操作，就会创建一条新的LSN，后续的所有操作都会携带上这个LSN")]),_._v(" "),r("ul",[r("li",[_._v("修改内存页中的page时，会更新page header的data_in_buffer_lsn")]),_._v(" "),r("li",[_._v("写入redo log buffer时，也会记录下这个操作的redo_log_on_disk_lsn")])]),_._v(" "),r("h5",{attrs:{id:"作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[_._v("#")]),_._v(" 作用")]),_._v(" "),r("p",[_._v("很多地方都用到了LSN，用来校验redo log被执行的一致性")]),_._v(" "),r("ul",[r("li",[_._v("数据页的版本信息\n在每个数据页的头部，有一个"),r("em",[_._v("fil_page_lsn")]),_._v("记录了当前页最终的LSN值是多少\nmysql进程crash后，使用redo log进行“恢复”时，通过比较数据页的LSN来判断这条redo log是否已经执行")]),_._v(" "),r("li",[_._v("刷盘check point标识")]),_._v(" "),r("li",[_._v("redo log buffer中组提交合并\n将一起提交的多个事务操作的LSN，取最大值")])]),_._v(" "),r("h4",{attrs:{id:"循环写入结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#循环写入结构"}},[_._v("#")]),_._v(" 循环写入结构")]),_._v(" "),r("p",[_._v("redo log默认由4个固定大小的文件组成，每个文件的大小为1GB")]),_._v(" "),r("p",[_._v("维护两个指针")]),_._v(" "),r("ul",[r("li",[r("p",[_._v("write pos 当前写入位置\n客户端写入操作会推进write pos的进度")])]),_._v(" "),r("li",[r("p",[_._v("checkpoint 当前要擦除的位置")]),_._v(" "),r("p",[_._v("指向已经落盘的操作日志")]),_._v(" "),r("p",[_._v("InnoDB会一个后台线程将redo log中记录的变更操作应用到磁盘的数据页中，推进checkpoint的进度")])])]),_._v(" "),r("p",[_._v("write pos和checkpoint之间的区域，可以被覆盖，写入新的redolog。")]),_._v(" "),r("p",[_._v("当write pos”追上“checkout，会导致无法再写入数据")]),_._v(" "),r("p",[r("img",{attrs:{src:a(583),alt:"image-20210909153943018"}})]),_._v(" "),r("h4",{attrs:{id:"写入机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#写入机制"}},[_._v("#")]),_._v(" 写入机制")]),_._v(" "),r("h5",{attrs:{id:"redo-log-buffer-【事务】"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redo-log-buffer-【事务】"}},[_._v("#")]),_._v(" redo log buffer 【事务】")]),_._v(" "),r("p",[_._v("redo log buffer是一块内存区域，用来保证redo log的事务一致性。")]),_._v(" "),r("p",[_._v("在事务执行的过程中，生成的redo log会先写到redo log buffer上。当"),r("strong",[_._v("事务")]),_._v("提交时，会将内存中的redo log持久化到redo log磁盘文件中。")]),_._v(" "),r("h5",{attrs:{id:"redo-log的写盘过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redo-log的写盘过程"}},[_._v("#")]),_._v(" redo log的写盘过程")]),_._v(" "),r("p",[_._v("redo log数据”经过“的三个区域：")]),_._v(" "),r("p",[r("img",{attrs:{src:a(584),alt:"image-20210909223512241"}})]),_._v(" "),r("ul",[r("li",[_._v("redo log buffer 位于mysql进程空间的内存区域【红色】\n首先redo log会被写redo log buffer中")]),_._v(" "),r("li",[_._v("FS page cache OS文件系统维护的page cache 位于内核空间的缓冲区【黄色】\nwrite系统调用：将redo log buffer中的数据写到FS page cache中【红-> 黄】")]),_._v(" "),r("li",[_._v("hard disk 磁盘【绿色】\nfsync系统调用（刷盘）：将FS page cache中的数据持久化到磁盘中【黄 -> 绿】")])]),_._v(" "),r("h5",{attrs:{id:"两阶段提交-【事务】"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#两阶段提交-【事务】"}},[_._v("#")]),_._v(" 两阶段提交 【事务】")]),_._v(" "),r("p",[_._v("redo log 和 binlog 是两个相互独立的操作，如果在两个操作过程中出现了崩溃导致其中一个操作没有执行成功，就会导致数据库的状态就有可能和用它的"),r("strong",[_._v("日志恢复出来的库的状态不一致")]),_._v("。")]),_._v(" "),r("p",[_._v("InnoDB设计了redo log两阶段提交来保证redo log与binlog的一致性")]),_._v(" "),r("p",[_._v("分为三步：redo log prepare阶段 -> 写入binlog -> redo log 提交阶段")]),_._v(" "),r("h3",{attrs:{id:"binlog-归档日志"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#binlog-归档日志"}},[_._v("#")]),_._v(" binlog 归档日志")]),_._v(" "),r("p",[_._v("binlog是Server级别的日志，最初是为MySQL自带的引擎MyISAM提供归档日志。")]),_._v(" "),r("h3",{attrs:{id:"binlog与redo-log的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#binlog与redo-log的区别"}},[_._v("#")]),_._v(" binlog与redo log的区别")]),_._v(" "),r("ul",[r("li",[_._v("binlog是Server级别的日志，redo log是InnoDB引擎内部实现来解决crash-safe能力")]),_._v(" "),r("li",[_._v("log格式不同\n"),r("ul",[r("li",[_._v("bin log 可以选择日志格式\n"),r("ul",[r("li",[_._v("row：记录的某个数据页某一行需要做什么操作")]),_._v(" "),r("li",[_._v("statement：记录的sql操作")])])]),_._v(" "),r("li",[_._v("redo log：记录的具体行的操作\n类似binlog的row模式")])])])]),_._v(" "),r("h2",{attrs:{id:"buffer-pool区域划分"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool区域划分"}},[_._v("#")]),_._v(" Buffer Pool区域划分")]),_._v(" "),r("p",[_._v("InnoDB划分的一块内存区域，用来存放缓存的数据结构")]),_._v(" "),r("ul",[r("li",[_._v("index page\n【"),r("strong",[_._v("全量")]),_._v("索引数据结构的缓存】\n磁盘中的InnoDB数据结构中的非叶子节点的缓存")]),_._v(" "),r("li",[_._v("data page\n【"),r("strong",[_._v("部分")]),_._v("数据行数据页的缓存】\n磁盘中的InnoDB数据结构中的叶子节点的缓存")]),_._v(" "),r("li",[_._v("undo log\n用于事务的回滚日志")]),_._v(" "),r("li",[_._v("change buffer\n记录数据操作")])]),_._v(" "),r("p",[_._v("主要讨论与读写优化相关的数据结构：data page和change buffer")]),_._v(" "),r("h2",{attrs:{id:"数据页读写缓存-data-page"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据页读写缓存-data-page"}},[_._v("#")]),_._v(" 数据页读写缓存 data page")]),_._v(" "),r("p",[_._v("InnoDB会根据数据的访问情况，动态的将磁盘中的数据，"),r("strong",[_._v("以数据页为单位")]),_._v("加载到缓存中。")]),_._v(" "),r("h3",{attrs:{id:"缓存读写流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#缓存读写流程"}},[_._v("#")]),_._v(" 缓存读写流程")]),_._v(" "),r("p",[_._v("客户端的读写操作不直接与磁盘中的数据页交互。而是会尽量操作缓存，然后通过"),r("strong",[_._v("后台线程异步")]),_._v("的将写操作的变更写到磁盘中的数据页。")]),_._v(" "),r("h4",{attrs:{id:"读操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#读操作"}},[_._v("#")]),_._v(" 读操作")]),_._v(" "),r("ul",[r("li",[_._v("缓存命中：目标数据页存在缓存中\n直接读取缓存中的数据返回")]),_._v(" "),r("li",[_._v("缓存未命中：目标缓存页不存在缓存中\n从磁盘中读取对应数据页\n检查是否有对应的change buffer，如果存在这执行merge操作，将merge之后的数据")])]),_._v(" "),r("h4",{attrs:{id:"写操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#写操作"}},[_._v("#")]),_._v(" 写操作")]),_._v(" "),r("ul",[r("li",[_._v("缓存命中：目标数据页存在缓存中\n对缓存中的数据页进行修改，并将该数据页标记为脏页")]),_._v(" "),r("li",[_._v("缓存未命中：目标缓存页不存在缓存中\n"),r("ul",[r("li",[_._v("检查待修改的字段是否被唯一索引限制，如果是非唯一索引，则写入到")])])])]),_._v(" "),r("h3",{attrs:{id:"内存回收-淘汰"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内存回收-淘汰"}},[_._v("#")]),_._v(" 内存回收/淘汰")]),_._v(" "),r("h3",{attrs:{id:"脏页刷盘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#脏页刷盘"}},[_._v("#")]),_._v(" 脏页刷盘")]),_._v(" "),r("h4",{attrs:{id:"触发时机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#触发时机"}},[_._v("#")]),_._v(" 触发时机")]),_._v(" "),r("ul",[r("li",[_._v("定时刷盘")]),_._v(" "),r("li",[_._v("merge")]),_._v(" "),r("li",[_._v("内存淘汰")])]),_._v(" "),r("h2",{attrs:{id:"change-buffer"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#change-buffer"}},[_._v("#")]),_._v(" change buffer")]),_._v(" "),r("p",[_._v("是InnoDB对写操作的一种优化，在保证一致性的前提下减少磁盘的IO")]),_._v(" "),r("p",[_._v("change buffer中记录了对不在缓存中的缓存数据页（data page）的"),r("strong",[_._v("合法修改操作")]),_._v("，避了update操作加载磁盘中的数据页。")]),_._v(" "),r("h3",{attrs:{id:"设计思想-懒加载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#设计思想-懒加载"}},[_._v("#")]),_._v(" 设计思想：懒加载")]),_._v(" "),r("p",[_._v("避免对磁盘的读写，在下一次读这个被修改的记录时，再从磁盘中加载对应的数据页，将change buffer中的操作merge到这个缓存页上。\n使用懒加载的思想，减少读磁盘，提升语句的执行速度。也减少了内存占用，提高内存的利用率。")]),_._v(" "),r("h3",{attrs:{id:"约束条件-非唯一索引"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#约束条件-非唯一索引"}},[_._v("#")]),_._v(" 约束条件：非唯一索引")]),_._v(" "),r("p",[_._v("只在"),r("strong",[_._v("非唯一索引")]),_._v("下适用，因为唯一索引会对操作进行唯一性校验，必须要查询磁盘数据。这样change buffer就失去了减少磁盘io的作用。")]),_._v(" "),r("h3",{attrs:{id:"与redo-log的比较"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#与redo-log的比较"}},[_._v("#")]),_._v(" 与redo log的比较")]),_._v(" "),r("p",[_._v("记录的内容格式是相同的")]),_._v(" "),r("h1",{attrs:{id:"参考"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[_._v("#")]),_._v(" 参考")]),_._v(" "),r("p",[_._v("https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html")])])}),[],!1,null,null,null);e.default=t.exports}}]);