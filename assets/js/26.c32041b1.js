(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{527:function(s,t,a){s.exports=a.p+"assets/img/image-20210613220234037.cc93fc56.png"},628:function(s,t,a){"use strict";a.r(t);var e=a(21),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,e=s._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"容器-vs-虚拟机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器-vs-虚拟机"}},[s._v("#")]),s._v(" 容器 vs 虚拟机")]),s._v(" "),e("p",[s._v("虚拟机的历史早于容器。虚拟机通过Hypervisor虚拟化硬件，模拟出运行操作系统运行需要的各种硬件，比如CPU、内存、I/O设备，然后在这个硬件资源上安装一个新的操作系统。")]),s._v(" "),e("p",[s._v("而容器本质上是运行在宿主机上的一个视图隔离、资源受限的"),e("strong",[s._v("进程")]),s._v("。")]),s._v(" "),e("p",[s._v("下图展示了使用容器与虚拟机中运行程序的区别")]),s._v(" "),e("p",[e("img",{attrs:{src:a(527),alt:"image-20210613220234037"}})]),s._v(" "),e("h2",{attrs:{id:"容器的优势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器的优势"}},[s._v("#")]),s._v(" 容器的优势")]),s._v(" "),e("h3",{attrs:{id:"轻量化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#轻量化"}},[s._v("#")]),s._v(" 轻量化")]),s._v(" "),e("p",[s._v("虚拟机必须运行一个完整的 Guest OS 才能执行用户的应用进程。这就不可避免地带来了额外的资源消耗和占用。容器作为宿主机的一个进程，直接使用宿主机的内核，额外开销可以忽略不计。此外，用户应用运行在虚拟机里面，它对宿主机操作系统的调用就不可避免地要经过虚拟化软件的拦截和处理，这本身又是一层性能损耗，尤其对计算资源、网络和磁盘 I/O 的损耗非常大。")]),s._v(" "),e("blockquote",[e("p",[s._v("根据实验，一个运行着 CentOS 的 KVM 虚拟机启动后，在不做优化的情况下，虚拟机自己就需要占用 100~200 MB 内存。")])]),s._v(" "),e("h3",{attrs:{id:"环境一致性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#环境一致性"}},[s._v("#")]),s._v(" 环境一致性")]),s._v(" "),e("p",[s._v("docker将应用程序的运行环境都视为一个可以叠加的文件系统（镜像），屏蔽了程序运行环境的差异带来的不确定性。并且将文件系统分层（layer）提高复用性，维护到中央仓库中。")]),s._v(" "),e("h2",{attrs:{id:"容器的劣势"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器的劣势"}},[s._v("#")]),s._v(" 容器的劣势")]),s._v(" "),e("h3",{attrs:{id:"隔离性不足"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#隔离性不足"}},[s._v("#")]),s._v(" 隔离性不足")]),s._v(" "),e("p",[s._v("容器只是宿主机的一种特殊的进程，各个容器使用的还是"),e("strong",[s._v("同一个宿主机操作系统的内核")]),s._v("。容器之间的隔离程度没有虚拟机的高，还有些资源不能被namespace隔离，比如时间。")]),s._v(" "),e("h1",{attrs:{id:"容器-有边界的进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器-有边界的进程"}},[s._v("#")]),s._v(" 容器：有边界的进程")]),s._v(" "),e("h2",{attrs:{id:"从进程说起"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从进程说起"}},[s._v("#")]),s._v(" 从进程说起")]),s._v(" "),e("p",[s._v("进程是正在运行的程序的实例，为应用程序"),e("strong",[s._v("提供运行环境")]),s._v("，是操作系统"),e("strong",[s._v("资源分配和调度")]),s._v("的基本单位。操作系统通过进程概念将计算机的硬件资源分配给多个应用程序。")]),s._v(" "),e("p",[s._v("无论是哪种语言编写的程序，最终都需要通过某种方式翻译成可以被计算机识别的"),e("strong",[s._v("二进制文件")]),s._v("，也称为可执行镜像（executable image）。")]),s._v(" "),e("p",[s._v("当程序被执行时，操作系统将二进制文件读取到进程的虚拟内存中并开始执行程序的指令。")]),s._v(" "),e("p",[s._v("执行过程中，会在中创建数据结构、堆栈中的方法调用指令、寄存器中的值、被打开的文件以及跟中设备的状态信息等，这些构成了"),e("strong",[s._v("程序执行环境的总和")]),s._v("，被操作系统封装在”进程“这个对象中。")]),s._v(" "),e("h2",{attrs:{id:"容器隔离进程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#容器隔离进程"}},[s._v("#")]),s._v(" 容器隔离进程")]),s._v(" "),e("p",[s._v("不受控制的进程会影响到运行在操作系统上的其他资源甚至操作系统本身。从而影响服务运行的稳定性和安全性。很多时候，一个bug或者仅仅只是烂代码就有可能破坏掉整个机器甚至可能削弱整个系统。")]),s._v(" "),e("p",[s._v("容器通过"),e("code",[s._v("cgroups")]),s._v("、"),e("code",[s._v("namespace")]),s._v("、"),e("code",[s._v("chroot")]),s._v("三种内核提供的功能接口实现进程的隔离。")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("cgroups")]),s._v(" 资源隔离")]),s._v(" "),e("li",[e("code",[s._v("namespace")]),s._v(" 进程视图隔离")]),s._v(" "),e("li",[e("code",[s._v("chroot")]),s._v(" 文件目录隔离")])]),s._v(" "),e("p",[s._v("启动一个busybox容器，作为后面说明的实验环境，用来查看容器内的情况")]),s._v(" "),e("div",{staticClass:"language-sh line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[s._v("docker run -it busybox /bin/sh\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("h3",{attrs:{id:"资源隔离-cgroups"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#资源隔离-cgroups"}},[s._v("#")]),s._v(" 资源隔离  "),e("code",[s._v("cgroups")])]),s._v(" "),e("p",[s._v("Linux内核提供了cgroups（控制组）全称Linux Control Group")]),s._v(" "),e("p",[s._v("用来限制、记录和隔离对个进程对CPU、内存、磁盘IO以及网络访问和使用量。此外，Cgroups 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。")]),s._v(" "),e("p",[s._v("在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下，供容器内的进程操作。")]),s._v(" "),e("p",[s._v("在busybox容器中使用命令"),e("code",[s._v("mount -t cgroup")]),s._v('来查看挂载在cgroup目录下的"文件"，可以看到'),e("code",[s._v("/sys/fs/cgroup/*")]),s._v('下提供的"资源句柄"')]),s._v(" "),e("div",{staticClass:"language-sh line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[s._v("cgroup on /sys/fs/cgroup/systemd "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("/usr/lib/systemd/systemd-cgroups-agent,name"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("systemd"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/cpuset "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,cpuset"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/net_cls,net_prio "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,net_prio,net_cls"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/pids "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,pids"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/hugetlb "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/cpu,cpuacct "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,cpuacct,cpu"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/devices "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,devices"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/freezer "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,freezer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/perf_event "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,perf_event"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/blkio "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,blkio"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\ncgroup on /sys/fs/cgroup/memory "),e("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("type")]),s._v(" cgroup "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("rw,nosuid,nodev,noexec,relatime,seclabel,memory"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br")])]),e("h3",{attrs:{id:"视图隔离-namespace"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#视图隔离-namespace"}},[s._v("#")]),s._v(" 视图隔离 "),e("code",[s._v("namespace")])]),s._v(" "),e("p",[s._v("linux内核使用namesplace命名空间的概念来隔离进程能看到的视图。提供了 PID、Mount、UTS、IPC、Network 和 User 这些 Namespace，用来对各种不同的进程上下文进行进行隔离。")]),s._v(" "),e("ul",[e("li",[s._v("PID Namespace：隔离进程间视图")]),s._v(" "),e("li",[s._v("Mount Namespace：隔离文件系统挂载点")]),s._v(" "),e("li",[s._v("Network Namespace：隔离网络设备和配置")])]),s._v(" "),e("p",[s._v("下面以进程隔离为例，进行演示容器的进程隔离")]),s._v(" "),e("p",[s._v("宿主机会为它分配一个pid，从宿主机视角查看进程，看到的pid为82246")]),s._v(" "),e("div",{staticClass:"language-sh line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[s._v("ps")]),s._v(" -ef"),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("grep")]),s._v(" busybox\n\n"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("501")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("82246")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("17009")]),s._v("   "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("12")]),s._v(":28PM ttys000    "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(":00.12 docker run -it busybox /bin/sh\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("从容器内部查看进程，这个sh终端的pid为1")]),s._v(" "),e("blockquote",[e("p",[s._v("容器与容器中pid=1的进程生命周期绑定，当这个进程退出时，容器也退出。")])]),s._v(" "),e("div",{staticClass:"language-sh line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-sh"}},[e("code",[s._v("/ "),e("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# ps")]),s._v("\nPID   "),e("span",{pre:!0,attrs:{class:"token environment constant"}},[s._v("USER")]),s._v("     TIME  COMMAND\n\t"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v("   root      "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(":00 /bin/sh\n\t"),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("8")]),s._v("   root      "),e("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),s._v(":00 "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("ps")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("p",[s._v("这两个pid指向的是同一个/bin/sh进程")]),s._v(" "),e("p",[s._v("容器使用了Linux内核的namespace机制，使得容器中不能看到宿主机里真正的进程空间，也不能看到其他 PID Namespace 里的具体情况，只能看到重新计算之后的进程编号。")]),s._v(" "),e("h4",{attrs:{id:"进程隔离实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#进程隔离实现"}},[s._v("#")]),s._v(" 进程隔离实现")]),s._v(" "),e("p",[s._v("在 Linux 系统中创建线程的系统调用方法： "),e("code",[s._v("clone()")])]),s._v(" "),e("div",{staticClass:"language-c line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" pid "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("clone")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("main_function"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" stack_size"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" CLONE_NEWPID "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("|")]),s._v(" SIGCHLD"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token constant"}},[s._v("NULL")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br")])]),e("p",[s._v("这个系统调用就会为我们创建一个新的进程，并且返回它的进程号 pid。")]),s._v(" "),e("p",[s._v("参数")]),s._v(" "),e("ul",[e("li",[s._v("main_function 进程的入口方法")]),s._v(" "),e("li",[s._v("stack_size         进程栈空间大小")]),s._v(" "),e("li",[e("code",[s._v("CLONE_NEWPID | SIGCHLD")]),s._v(" 启动标识\n"),e("ul",[e("li",[e("code",[s._v("SIGCHLD")]),s._v(" 创建普通进程")]),s._v(" "),e("li",[e("code",[s._v("CLONE_NEWPID")]),s._v(" 创建独立的进程")])])])]),s._v(" "),e("p",[s._v("创建容器时，使用"),e("code",[s._v("CLONE_NEWPID")]),s._v("参数会创建独立的进程，新创建的这个进程将会“看到”一个全新的进程空间，在这个进程空间里，它的 PID 是 1")]),s._v(" "),e("h3",{attrs:{id:"文件隔离-chroot"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#文件隔离-chroot"}},[s._v("#")]),s._v(" 文件隔离 "),e("code",[s._v("chroot")])]),s._v(" "),e("p",[s._v("创建容器时，docker为进程重新指定根目录（rootfs），在指定的目录中”准备“完整的linux系统的全部文件（只包含操作系统的所有文件、配置和目录，"),e("strong",[s._v("不包含操作系统内核")]),s._v("以文件形式提供的接口）。")]),s._v(" "),e("h4",{attrs:{id:"联合文件系统-union-file-system"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#联合文件系统-union-file-system"}},[s._v("#")]),s._v(" 联合文件系统（Union File System）")]),s._v(" "),e("p",[s._v("在上文"),e("RouterLink",{attrs:{to:"/views/cloud-native/docker/2021/20210613.html#环境一致性"}},[s._v("容器优势-环境一致性")]),s._v("中简单提到了容器进行分层的概念。在创建容器时，会将容器镜像的不同层（layer）以及containers下的可读写配置文件联合挂载到同一个目录下，作为容器的rootfs。")],1),s._v(" "),e("p",[s._v("将不同的目录联合挂载到同一个目录下就是所谓的联合文件系统。有多种不同的实现，可以通过"),e("code",[s._v("docker info|grep 'Backing Filesystem'")]),s._v(" 来查看当前docker版本的实现方式。")]),s._v(" "),e("h4",{attrs:{id:"docker工作目录"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#docker工作目录"}},[s._v("#")]),s._v(" docker工作目录")]),s._v(" "),e("p",[s._v("docker中不同的文件系统实现会有不同的工作目录结构，以实验机器（CentOS系统，18.09.0 Docker-CE）为例")]),s._v(" "),e("p",[s._v("该版本使用的Backing Filesystem使用的xfs，Storage Driver使用的overlay2")]),s._v(" "),e("p",[s._v("在Docker Root Dir目录下存放了容器文件系统需要的目录")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("containers")]),s._v(" 用来保存运行容器的可读写文件")]),s._v(" "),e("li",[e("code",[s._v("overlay2")]),s._v(" 用来拉取的镜像layer文件")])])])}),[],!1,null,null,null);t.default=n.exports}}]);