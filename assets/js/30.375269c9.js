(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{599:function(e,t,a){e.exports=a.p+"assets/img/TB1G0L6KpXXXXbOXVXXXXXXXXXX.289e121a.png"},661:function(e,t,a){"use strict";a.r(t);var r=a(21),v=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"rocketmq数据模型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq数据模型"}},[e._v("#")]),e._v(" RocketMQ数据模型")]),e._v(" "),r("p",[e._v("RocketMQ的消息数据存储在topic逻辑分区，一个topic可以包含多个MessageQueue，这些MessageQueue可以分布在多个broker节点上，多个broker为一个topic提供消息服务，分担网络负载和磁盘存储")]),e._v(" "),r("h2",{attrs:{id:"topic"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#topic"}},[e._v("#")]),e._v(" Topic")]),e._v(" "),r("p",[e._v("作为消息的逻辑分区，用来隔离不同的数据域")]),e._v(" "),r("h2",{attrs:{id:"messagequeue"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#messagequeue"}},[e._v("#")]),e._v(" MessageQueue")]),e._v(" "),r("p",[e._v("作为消息的逻辑存储单元，一个Topic下默认4个messageQueue")]),e._v(" "),r("h1",{attrs:{id:"存储原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存储原理"}},[e._v("#")]),e._v(" 存储原理")]),e._v(" "),r("p",[e._v("broker接收到消息后，会将消息存到对应的MessageQueue中")]),e._v(" "),r("p",[e._v("MessageQueue作为消息数据的逻辑单元，分布在topic对应集群的不同broker节点上")]),e._v(" "),r("p",[e._v("在broker中MessageQueue是通过CommitLog和ComsumeQueue共同实现")]),e._v(" "),r("h2",{attrs:{id:"存储策略-提高io效率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存储策略-提高io效率"}},[e._v("#")]),e._v(" 存储策略（提高IO效率）")]),e._v(" "),r("h3",{attrs:{id:"顺序写"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#顺序写"}},[e._v("#")]),e._v(" 顺序写")]),e._v(" "),r("p",[e._v("消息数据CommitLog和ConsumeQueue的持久化都是通过按时间顺序追加写入文件，提高数据写盘的性能")]),e._v(" "),r("blockquote",[r("p",[e._v("磁盘的速度完全可以匹配上网络的数据传输速度，目前的高性能磁盘，顺序写速度可以达到600MB/s，超过了一般网卡的传输速度。")]),e._v(" "),r("p",[e._v("而磁盘的随机写的速度只有100KB/s，和顺序写的性能差了好几个数量级。")])]),e._v(" "),r("h3",{attrs:{id:"元数据和payload分离"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#元数据和payload分离"}},[e._v("#")]),e._v(" 元数据和payload分离")]),e._v(" "),r("p",[e._v("CommitLog只存储消息体，纯payload二进制数据，消息的其他元数据以索引的方式保存在ConsumeQueue文件中")]),e._v(" "),r("h3",{attrs:{id:"异步刷盘-pagecache"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步刷盘-pagecache"}},[e._v("#")]),e._v(" 异步刷盘 - pageCache")]),e._v(" "),r("p",[e._v("基于操作系统的PageCache和顺序写的两种机制，来提升CommitLog文件的性能")]),e._v(" "),r("p",[r("img",{attrs:{src:a(599),alt:"img"}})]),e._v(" "),r("p",[e._v("写入CommitLog文件的时候，不是直接写入底层的物理磁盘文件的，而是先进入"),r("strong",[e._v("OS的PageCache内存缓存")]),e._v("中，然后后续由OS的后台线程选一个时间，异步化的将OS PageCache内存缓冲中的数据刷入底层的磁盘文件，这就是所谓的"),r("strong",[e._v("异步刷盘")])]),e._v(" "),r("h4",{attrs:{id:"同步刷盘-保证数据安全"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步刷盘-保证数据安全"}},[e._v("#")]),e._v(" 同步刷盘 - 保证数据安全")]),e._v(" "),r("p",[e._v("调用操作系统的写入命令时，当数据写入物理磁盘后才会返回ACK（表示数据写入成功）")]),e._v(" "),r("ul",[r("li",[e._v("优点：数据不丢失")]),e._v(" "),r("li",[e._v("缺点：降低吞吐量作为代价")])]),e._v(" "),r("h4",{attrs:{id:"异步刷盘-提高写盘效率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步刷盘-提高写盘效率"}},[e._v("#")]),e._v(" 异步刷盘 - 提高写盘效率")]),e._v(" "),r("p",[e._v("异步刷盘模式下，当数据写入到PageCache，操作系统就会返回ACK（表示数据写入成功），这样虽然能提高写入的效率，提高吞吐量")]),e._v(" "),r("p",[e._v("但同时也会存在丢失数据的问题：当数据写入到PageCache当没有来得及写入到磁盘时，这部分内存中的数据就会丢失")]),e._v(" "),r("h2",{attrs:{id:"存储数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存储数据结构"}},[e._v("#")]),e._v(" 存储数据结构")]),e._v(" "),r("h3",{attrs:{id:"commitlog-存储payload"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#commitlog-存储payload"}},[e._v("#")]),e._v(" CommitLog 存储payload")]),e._v(" "),r("p",[e._v("broker接收到消息后，会"),r("strong",[e._v("顺序")]),e._v("的将消息体（payload）以二进制的形式写入到CommitLog目录下的CommitLog文件")]),e._v(" "),r("p",[e._v("每一个文件大小限制为1GB")]),e._v(" "),r("h4",{attrs:{id:"目录位置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#目录位置"}},[e._v("#")]),e._v(" 目录位置")]),e._v(" "),r("p",[e._v("通过broker启动配置文件的"),r("code",[e._v("storePathCommitLog")]),e._v("属性设置CommitLog目录位置")]),e._v(" "),r("p",[e._v("例如："),r("code",[e._v("storePathCommitLog=/tmp/rmqstore/node00/commitlog")])]),e._v(" "),r("h3",{attrs:{id:"consumequeue-存储元数据"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#consumequeue-存储元数据"}},[e._v("#")]),e._v(" ConsumeQueue 存储元数据")]),e._v(" "),r("blockquote",[r("p",[e._v("类似"),r("strong",[e._v("索引")]),e._v("的概念，ConsumeQueue文件里存储的每一条消息对应在CommitLog文件中的消息数据的读取信息")]),e._v(" "),r("p",[e._v("commitLog只单纯的负责存储数据（没有额外的数据结构来表示message属于哪个topic的哪个MessageQueue）。需要通过ConsumeQueue文件来区分这些数据对应的是broker下的MessageQueue")])]),e._v(" "),r("p",[r("strong",[e._v("写入")]),e._v("时，broker的接收到的所有消息顺序存储到commitLog中，同时会根据消息的topic和MessageQueue，将commitLog中的消息的存储信息【"),r("strong",[e._v("物理存储地址（offset）")]),e._v("、存储的数据"),r("strong",[e._v("长度")]),e._v("、消息的"),r("strong",[e._v("tag")]),e._v(" 没一条数据长度为20B】写到对应的ConsumeQueue文件中")]),e._v(" "),r("p",[r("strong",[e._v("查询")]),e._v("时，MessageQueue通过topic、queueId找到ConsumeQueue文件，读取索引找到commitLog中的消息数据")]),e._v(" "),r("blockquote",[r("p",[e._v("存储文件："),r("code",[e._v("$HOME/store/consumequeue/{topic}/{queueId}/{fileName}")])]),e._v(" "),r("p",[e._v("例如一个名为order的topic，在当前broker下有个两个MessageQueue，则对应的ConsumeQueue文件为")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("$HOME/store/consumequeue/order")]),e._v(" "),r("ul",[r("li",[e._v("MessageQueueID0\n"),r("ul",[r("li",[e._v("ConsumeQueue0")]),e._v(" "),r("li",[e._v("ConsumeQueue1")]),e._v(" "),r("li",[e._v("···")])])]),e._v(" "),r("li",[e._v("MessageQueueID1\n"),r("ul",[r("li",[e._v("ConsumeQueue0")]),e._v(" "),r("li",[e._v("ConsumeQueue1")]),e._v(" "),r("li",[e._v("···")])])])])])])]),e._v(" "),r("h2",{attrs:{id:"主从集群"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主从集群"}},[e._v("#")]),e._v(" 主从集群")]),e._v(" "),r("p",[e._v("一组broker组成的高可用的主从集群中，其中一个master角色和多个slave角色：")]),e._v(" "),r("p",[e._v("master接收producer客户端的写请求后，将数据同步给其他的slave节点")]),e._v(" "),r("h3",{attrs:{id:"主从复制模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#主从复制模式"}},[e._v("#")]),e._v(" 主从复制模式")]),e._v(" "),r("p",[e._v("同步复制和异步复制是通过Broker配置文件里的brokerRole参数进行设置的，这个参数可以被设置成ASYNC_MASTER、SYNC_MASTER、SLAVE三个值中的一个")]),e._v(" "),r("h4",{attrs:{id:"同步复制-强一致-cp"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#同步复制-强一致-cp"}},[e._v("#")]),e._v(" 同步复制 - 强一致 CP")]),e._v(" "),r("p",[e._v("master接收到消息后，等到master和slave均写成功，才会返回客户端消息发送成功")]),e._v(" "),r("h4",{attrs:{id:"异步复制-最终一致-ap"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步复制-最终一致-ap"}},[e._v("#")]),e._v(" 异步复制 - 最终一致 AP")]),e._v(" "),r("p",[e._v("master接收到消息后，只要master写成功了，就会返回客户端消息发送成功，同步到slave节点的动作异步进行")]),e._v(" "),r("h3",{attrs:{id:"dledger-主从选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#dledger-主从选举"}},[e._v("#")]),e._v(" DLedger 主从选举")]),e._v(" "),r("blockquote",[r("p",[e._v("当master节点宕机后，rocketmq没有自带的主从切换实现，而是需要"),r("strong",[e._v("手动")]),e._v("修改一个slave节点的配置然后重启，将slave切换成master")]),e._v(" "),r("p",[e._v("引入DLedger插件可以实现leader宕机后，follow节点选举出新的leader，并自动切换")])]),e._v(" "),r("p",[e._v("开启DLedger插件，会"),r("strong",[e._v("替代broker来管理CommitLog")])]),e._v(" "),r("h4",{attrs:{id:"开启dledger功能"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#开启dledger功能"}},[e._v("#")]),e._v(" 开启DLedger功能")]),e._v(" "),r("h5",{attrs:{id:"安装dledger组件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#安装dledger组件"}},[e._v("#")]),e._v(" 安装DLedger组件")]),e._v(" "),r("p",[e._v("DLedger是一个"),r("strong",[e._v("独立的进程")]),e._v("，在每一个broker节点上安装一个DLedger服务，DLedger服务会监听一个端口，用于集群中DLedger服务之间的通信")]),e._v(" "),r("h5",{attrs:{id:"broker配置开启dledger模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#broker配置开启dledger模式"}},[e._v("#")]),e._v(" broker配置开启DLedger模式")]),e._v(" "),r("h4",{attrs:{id:"raft协议-选举"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#raft协议-选举"}},[e._v("#")]),e._v(" Raft协议-选举")]),e._v(" "),r("ul",[r("li",[e._v("设定每个节点默认投票给自己")]),e._v(" "),r("li",[e._v("如果一轮选举结果 都是选自己，所有节点休眠随机一段时间")]),e._v(" "),r("li",[e._v("先唤醒的节点投自己并广播到其他节点")]),e._v(" "),r("li",[e._v("后唤醒的节点收到之前唤醒节点的投票后，会投票给先唤醒的节点")]),e._v(" "),r("li",[e._v("最终会选举出最先被唤醒的节点 作为master")])]),e._v(" "),r("h3",{attrs:{id:"raft协议-多副本同步"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#raft协议-多副本同步"}},[e._v("#")]),e._v(" Raft协议-多副本同步")]),e._v(" "),r("p",[e._v("数据同步会分为两个阶段：uncommitted阶段和committed阶段")]),e._v(" "),r("h4",{attrs:{id:"uncommitted状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#uncommitted状态"}},[e._v("#")]),e._v(" uncommitted状态")]),e._v(" "),r("p",[e._v("Leader节点上的DLedger收到一条数据后，会标记为uncommitted状态，通过自己的DLedgerServer组件把这个uncommitted数据发送给Follower Broker的DLedgerServer。")]),e._v(" "),r("h4",{attrs:{id:"committed状态"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#committed状态"}},[e._v("#")]),e._v(" committed状态")]),e._v(" "),r("p",[e._v("Follower Broker的DLedgerServer收到uncommitted消息之后，必须返回一个ack给Leader  Broker的DLedgerServer，然后如果Leader Broker收到"),r("strong",[e._v("超过半数")]),e._v("的Follower  Broker返回ack之后，就会将消息标记为committed状态。")]),e._v(" "),r("p",[e._v("然后Leader Broker上的DLedgerServer就会发送commited消息给Follower Broker机器的DLedgerServer，让他们也把消息标记为comitted状态。")]),e._v(" "),r("h2",{attrs:{id:"消息数据清理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息数据清理"}},[e._v("#")]),e._v(" 消息数据清理")]),e._v(" "),r("p",[e._v("RocketMQ会将消息持久化到磁盘。但是不会像mysql一样，永久将数据保存在磁盘上，因为消息队列中间件设计的目的是数据中转而不是数据存储")]),e._v(" "),r("h3",{attrs:{id:"定时任务清理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定时任务清理"}},[e._v("#")]),e._v(" 定时任务清理")]),e._v(" "),r("h4",{attrs:{id:"删除触发条件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#删除触发条件"}},[e._v("#")]),e._v(" 删除触发条件")]),e._v(" "),r("p",[e._v("rocketMQ内部的消息清理机制，每10s执行一次CleanCommitLogService")]),e._v(" "),r("p",[e._v("不是每10s删除一次，而是没10s"),r("strong",[e._v("检查是否满足开启清理任务")]),e._v("的条件")]),e._v(" "),r("ul",[r("li",[r("p",[e._v("timeup：到每天指定的时间点 默认设置是每天凌晨4点")]),e._v(" "),r("p",[r("code",[e._v('private String deleteWhen = "04";')])])]),e._v(" "),r("li",[r("p",[e._v("spacefull：磁盘满")]),e._v(" "),r("ul",[r("li",[r("code",[e._v("diskMaxUsedSpaceRatio")]),e._v("：磁盘最大利用率 默认是"),r("code",[e._v("75")]),e._v("，超过则触发消息清理")]),e._v(" "),r("li",[r("code",[e._v("DiskSpaceCleanForciblyRatio")]),e._v("：磁盘空间"),r("strong",[e._v("强制删除")]),e._v("文件水位。默认是"),r("code",[e._v("85")])]),e._v(" "),r("li",[r("code",[e._v("DiskSpaceWarningLevelRatio")]),e._v("：磁盘空间警戒水位 默认是"),r("code",[e._v("90")]),e._v("，超过则"),r("strong",[e._v("停止接收新消息")])])])]),e._v(" "),r("li",[r("p",[e._v("manualDelete：手动触发删除")])])]),e._v(" "),r("h4",{attrs:{id:"清理策略"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#清理策略"}},[e._v("#")]),e._v(" 清理策略")]),e._v(" "),r("h5",{attrs:{id:"文件删除顺序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#文件删除顺序"}},[e._v("#")]),e._v(" 文件删除顺序")]),e._v(" "),r("p",[e._v("commitLog是顺序写盘的，删除文件时也是用序号较小的commitLog文件开始删除")]),e._v(" "),r("h5",{attrs:{id:"文件过期删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#文件过期删除"}},[e._v("#")]),e._v(" 文件过期删除")]),e._v(" "),r("p",[e._v("满足删除触发条件后，会删除过期的文件（"),r("strong",[e._v("删除的单位是文件而不是消息")]),e._v("）")]),e._v(" "),r("p",[e._v("消息过期配置文件的过期时间 "),r("code",[e._v("fileReservedTime")]),e._v("：文件过期时间，也就是从文件最后一次的更新时间到现在为止，如果超过该时间，则是过期文件可被删除")]),e._v(" "),r("p",[e._v("由于commitLog是顺序写入且不会修改已经写入的消息。清理文件时，只需要循序")]),e._v(" "),r("h5",{attrs:{id:"限量删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#限量删除"}},[e._v("#")]),e._v(" 限量删除")]),e._v(" "),r("p",[e._v("每次触发删除操作最多运行删除10个commitLog文件，因为删除操作会占用IO资源，降低插入消息的性能")]),e._v(" "),r("p",[e._v("通过设置"),r("code",[e._v("deletePhysicFilesInterval")]),e._v(" 删除物理文件的时间间隔")]),e._v(" "),r("h5",{attrs:{id:"强制删除"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#强制删除"}},[e._v("#")]),e._v(" 强制删除")]),e._v(" "),r("p",[e._v("当磁盘使用率大于85%（超过磁盘空间强制删除文件水位 "),r("code",[e._v("DiskSpaceCleanForciblyRatio")]),e._v("）")]),e._v(" "),r("p",[e._v("由于前面的删除顺序和限量删除，强制删除一次最多只会删除10个生成时间最早的commitLog")]),e._v(" "),r("blockquote",[r("p",[e._v("参考")]),e._v(" "),r("p",[e._v("https://blog.csdn.net/Memery_last/article/details/83791165")]),e._v(" "),r("p",[e._v("https://www.jianshu.com/p/2ce8aa1bd438")]),e._v(" "),r("p",[e._v("https://www.jianshu.com/p/96a011a30d6a")])])])}),[],!1,null,null,null);t.default=v.exports}}]);