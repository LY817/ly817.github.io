(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{585:function(t,v,_){t.exports=_.p+"assets/img/1544274368235.0074326d.png"},586:function(t,v,_){t.exports=_.p+"assets/img/1544271671971.99eb1435.png"},587:function(t,v,_){t.exports=_.p+"assets/img/1544273434894.f540f51f.png"},588:function(t,v,_){t.exports=_.p+"assets/img/1544276396033.0eeaf2f9.png"},657:function(t,v,_){"use strict";_.r(v);var a=_(21),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,a=t._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("锁机制是为了解决公共资源的并发操作导致的数据不一致问题")]),t._v(" "),a("h3",{attrs:{id:"单进程情况下-即多线程并发访问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#单进程情况下-即多线程并发访问"}},[t._v("#")]),t._v(" 单进程情况下：即多线程并发访问")]),t._v(" "),a("p",[t._v("在一个JVM进程中，JDK的API提供了丰富的解决方案，比如synchronized关键字（被动同步锁标记）、lock（主动加锁）、volatile（可见性）、concurrent工具包（原子类）")]),t._v(" "),a("h3",{attrs:{id:"多进程情况下-分布式系统中的并发访问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多进程情况下-分布式系统中的并发访问"}},[t._v("#")]),t._v(" 多进程情况下：分布式系统中的并发访问")]),t._v(" "),a("p",[t._v("在一个高并发业务的服务集群中，大量的业务请求被分流到集群中不同的进程中进行处理，会出现运行在多个JVM中的相同业务逻辑对同一业务对象进行访问和操作。这种情况下，无法使用JDK提供的并发api来保证数据的一致性")]),t._v(" "),a("p",[t._v("分布式锁就是将位于不同进程中的数据状态集中在一个统一的进程（"),a("strong",[t._v("公共资源池")]),t._v("）中进行协调和管理。保证不同进程对同一个数据的操作"),a("strong",[t._v("互斥")]),t._v("，保证对资源的"),a("strong",[t._v("顺序访问")])]),t._v(" "),a("h2",{attrs:{id:"关键特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#关键特性"}},[t._v("#")]),t._v(" 关键特性")]),t._v(" "),a("h3",{attrs:{id:"互斥"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#互斥"}},[t._v("#")]),t._v(" 互斥")]),t._v(" "),a("p",[t._v("在任意时刻，只有一个客户端能持有锁")]),t._v(" "),a("h3",{attrs:{id:"超时过期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时过期"}},[t._v("#")]),t._v(" 超时过期")]),t._v(" "),a("p",[t._v("锁状态添加一个过期时间，防止锁的持有进程异常退出无法解锁导致的"),a("strong",[t._v("死锁")])]),t._v(" "),a("h3",{attrs:{id:"可重入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可重入"}},[t._v("#")]),t._v(" 可重入")]),t._v(" "),a("p",[t._v("对于已经获取资源锁状态的进程，还可以对该资源加锁，应锁状态中对应的一个计数器加一；解锁时，计数器减一，计数器归零时，锁状态解除")]),t._v(" "),a("h3",{attrs:{id:"阻塞"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞"}},[t._v("#")]),t._v(" 阻塞")]),t._v(" "),a("p",[t._v("当获取锁失败时，执行进入阻塞状态，直到获取锁再执行后续逻辑")]),t._v(" "),a("h1",{attrs:{id:"数据库表乐观锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据库表乐观锁"}},[t._v("#")]),t._v(" 数据库表乐观锁")]),t._v(" "),a("h2",{attrs:{id:"加锁机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加锁机制"}},[t._v("#")]),t._v(" 加锁机制")]),t._v(" "),a("h3",{attrs:{id:"原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),a("p",[t._v("数据库中创建一张表来存放公共资源的状态，表的字段有：")]),t._v(" "),a("ul",[a("li",[t._v("主键")]),t._v(" "),a("li",[t._v("公共资源的唯一标识 - "),a("strong",[t._v("唯一约束")])]),t._v(" "),a("li",[t._v("创建时间")])]),t._v(" "),a("p",[t._v("加锁时，向表中插入一条数据"),a("code",[t._v('insert into lock_table ("my_lock_1","2018-12-08 15:15:28");')])]),t._v(" "),a("p",[t._v("其他线程要获得my_lock_1锁的操作权限时，执行插入操作会抛出唯一约束异常，从而加锁失败。")]),t._v(" "),a("p",[t._v("解锁时只用删除之前插入的记录")]),t._v(" "),a("h3",{attrs:{id:"缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),a("p",[t._v("锁的超时性、重入性、阻塞性，都需要在程序中解决")]),t._v(" "),a("p",[t._v("执行效率低，不适合高并发场景，尴尬的是分布式锁就是用在高并发的场景")]),t._v(" "),a("h5",{attrs:{id:"超时解锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#超时解锁"}},[t._v("#")]),t._v(" 超时解锁")]),t._v(" "),a("p",[t._v("当加锁的进程加锁之后抛出异常，没有执行解锁操作，就形成了死锁。")]),t._v(" "),a("p",[t._v("需要建一个定时任务，根据创建时间将超时的锁记录删除")]),t._v(" "),a("h5",{attrs:{id:"阻塞-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#阻塞-2"}},[t._v("#")]),t._v(" 阻塞")]),t._v(" "),a("p",[t._v("只能在程序中do-while的方式不停的轮询尝试上锁，知道上锁成功，再进行后面的逻辑")]),t._v(" "),a("h5",{attrs:{id:"重入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重入"}},[t._v("#")]),t._v(" 重入")]),t._v(" "),a("p",[t._v("需要添加新的字段：获取锁线程的主机和进程信息以及上锁计数")]),t._v(" "),a("p",[t._v("同时还需要修改上锁和解锁逻辑：")]),t._v(" "),a("ul",[a("li",[t._v("上锁：第一次上锁insert，第二次上锁update计数")]),t._v(" "),a("li",[t._v("解锁：先检查计数，大于1时，计数减一；等于1时，删除记录")])]),t._v(" "),a("h1",{attrs:{id:"redis实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis实现分布式锁"}},[t._v("#")]),t._v(" Redis实现分布式锁")]),t._v(" "),a("p",[t._v("将锁状态以redis中唯一性的key来表示")]),t._v(" "),a("h2",{attrs:{id:"加锁机制-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加锁机制-2"}},[t._v("#")]),t._v(" 加锁机制")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("setnx")]),t._v("命令上锁：如果key存在返回0，表示获取锁失败")]),t._v(" "),a("p",[t._v("使用"),a("code",[t._v("get")]),t._v("或"),a("code",[t._v("getset")]),t._v("命令尝试获得锁")]),t._v(" "),a("p",[t._v("将锁状态信息以键值对的形式保存储")]),t._v(" "),a("ul",[a("li",[t._v("键：公共资源的"),a("strong",[t._v("唯一标识")]),t._v(" lock-key （作为基本的锁资源映射）")]),t._v(" "),a("li",[t._v("值：用于实现锁的高级特性\n"),a("ul",[a("li",[t._v("当前时间戳+过期时间：替代设置过期时间（redis维护过期），程序主动维护过期")]),t._v(" "),a("li",[t._v("加锁者唯一id：用于解锁是检查（锁必须由加锁者解锁）")]),t._v(" "),a("li",[t._v("map对象：存放键值对 加锁操作id-计数器 实现"),a("strong",[t._v("重入锁")])])])])]),t._v(" "),a("h3",{attrs:{id:"使用到的命令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用到的命令"}},[t._v("#")]),t._v(" 使用到的命令")]),t._v(" "),a("h4",{attrs:{id:"setnx-key-value-set-if-not-exits"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setnx-key-value-set-if-not-exits"}},[t._v("#")]),t._v(" setnx(key,value) - set if not exits")]),t._v(" "),a("p",[t._v("如果key-value不存在，这将k-v存入缓存中并返回1，否则返回0")]),t._v(" "),a("h4",{attrs:{id:"get-key"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#get-key"}},[t._v("#")]),t._v(" get(key)")]),t._v(" "),a("p",[t._v("获取key对应的value，不存在则返回nil")]),t._v(" "),a("h4",{attrs:{id:"getset-key-value"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getset-key-value"}},[t._v("#")]),t._v(" getset(key,value)")]),t._v(" "),a("p",[t._v("先获取key对应的value值，若不存在则返回nil，然后将旧的value更新为新的value")]),t._v(" "),a("h4",{attrs:{id:"expire-key-seconds"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expire-key-seconds"}},[t._v("#")]),t._v(" expire(key, seconds)")]),t._v(" "),a("p",[t._v("设置key的有效期为seconds秒")]),t._v(" "),a("h3",{attrs:{id:"加锁流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加锁流程"}},[t._v("#")]),t._v(" 加锁流程")]),t._v(" "),a("p",[t._v("获得锁失败时，轮询解锁")]),t._v(" "),a("p",[a("img",{attrs:{src:_(585),alt:"1544274368235"}})]),t._v(" "),a("h3",{attrs:{id:"可重入-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可重入-2"}},[t._v("#")]),t._v(" 可重入")]),t._v(" "),a("p",[t._v("使用map结构")]),t._v(" "),a("p",[t._v("map中key为客户端唯一标识，value为重入计数器")]),t._v(" "),a("p",[t._v("当第一次获取锁时，map存入key为客户端唯一标识，value为1")]),t._v(" "),a("p",[t._v("当重入锁时，对value进行+1/-1操作，当value=0时，退出锁占用")]),t._v(" "),a("h3",{attrs:{id:"自动续期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动续期"}},[t._v("#")]),t._v(" 自动续期")]),t._v(" "),a("p",[t._v("正常情况下，占用锁资源的时长会小于redis中锁的过期时间。")]),t._v(" "),a("p",[t._v("但如果占用资源的进程出现里阻塞情况（但进程没有宕机最终会执行完成，比如数据库操作阻塞或发生了Full GC STW），导致redis中的锁过期（添加过期时间是为了防止持有锁的进程宕机导致死锁）自动释放，从而导致锁的状态异常")]),t._v(" "),a("blockquote",[a("p",[t._v("导致锁的状态异常过程")]),t._v(" "),a("ul",[a("li",[t._v("进程A的锁应超时释放")]),t._v(" "),a("li",[t._v("进程B获取锁")]),t._v(" "),a("li",[t._v("此时进程A执行完成，会请求Redis释放占用资源锁（此时释放的是进程B占用的资源锁）")])])]),t._v(" "),a("h4",{attrs:{id:"解决方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[t._v("#")]),t._v(" 解决方案")]),t._v(" "),a("h5",{attrs:{id:"自动续期-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自动续期-2"}},[t._v("#")]),t._v(" 自动续期")]),t._v(" "),a("p",[t._v("在客户端使用一个线程来维护redis中的锁状态")]),t._v(" "),a("h5",{attrs:{id:"解锁前检查token"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解锁前检查token"}},[t._v("#")]),t._v(" 解锁前检查token")]),t._v(" "),a("p",[t._v("在上锁的时候，进程存放一个自己的唯一标识token作为value。再解锁时，检查token释放一致")]),t._v(" "),a("hr"),t._v(" "),a("blockquote",[a("p",[t._v("扩展阅读")]),t._v(" "),a("ul",[a("li",[t._v("开源框架"),a("strong",[t._v("Redssion")]),t._v("：\n"),a("ul",[a("li",[t._v("使用lua脚本保证锁操作的原子性")]),t._v(" "),a("li",[t._v("实现"),a("code",[t._v("java.util.concurrent.locks.Lock")]),t._v(" API")]),t._v(" "),a("li",[t._v("实现了可重入性和自动续期")])])]),t._v(" "),a("li",[a("a",{attrs:{href:"https://blog.csdn.net/hcmony/article/details/80694560",target:"_blank",rel:"noopener noreferrer"}},[t._v("Redis分布式锁的优缺点和一些细节"),a("OutboundLink")],1)])])]),t._v(" "),a("h1",{attrs:{id:"zookeeper实现分布式锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zookeeper实现分布式锁"}},[t._v("#")]),t._v(" ZooKeeper实现分布式锁")]),t._v(" "),a("p",[t._v("将锁状态以zk中"),a("strong",[t._v("临时顺序节点")]),t._v("的形式表示")]),t._v(" "),a("blockquote",[a("p",[a("strong",[t._v("长连接")])]),t._v(" "),a("p",[t._v("zookeeper的客户端与服务端使用长连接通信，简化实现分布式的操作")]),t._v(" "),a("ul",[a("li",[t._v("不需要考虑死锁的超时过期，不用设置过期时间（断开连接即解锁）")]),t._v(" "),a("li",[a("strong",[t._v("不需要轮询")]),t._v("查看锁的状态（通过监听器感知解锁）")])]),t._v(" "),a("p",[a("strong",[t._v("有序节点")])]),t._v(" "),a("p",[t._v("通过有序节点保证对锁的"),a("strong",[t._v("顺序访问")])])]),t._v(" "),a("h2",{attrs:{id:"加锁机制-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加锁机制-3"}},[t._v("#")]),t._v(" 加锁机制")]),t._v(" "),a("h3",{attrs:{id:"使用到的特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用到的特性"}},[t._v("#")]),t._v(" 使用到的特性")]),t._v(" "),a("h4",{attrs:{id:"临时节点-保证了不会死锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#临时节点-保证了不会死锁"}},[t._v("#")]),t._v(" 临时节点：保证了不会死锁")]),t._v(" "),a("p",[t._v("客户端可以建立一个临时节点，在"),a("strong",[t._v("会话结束或者会话超时")]),t._v("后，zookeeper会自动删除该节点。")]),t._v(" "),a("h4",{attrs:{id:"有序节点-实现公平锁-排队-先到先获取-和可重入锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有序节点-实现公平锁-排队-先到先获取-和可重入锁"}},[t._v("#")]),t._v(" 有序节点：实现公平锁（排队 先到先获取）和可重入锁")]),t._v(" "),a("p",[t._v("假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；")]),t._v(" "),a("p",[t._v("zookeeper提供了一个可选的有序特性，例如我们可以创建子节点“/lock/node-”并且指明有序，那么zookeeper在生成子节点时会根据当前的子节点数量自动添加整数序号，也就是说如果是第一个创建的子节点，那么生成的子节点为/lock/node-0000000000，下一个节点则为/lock/node-0000000001，依次类推。")]),t._v(" "),a("blockquote",[a("p",[t._v("区别于节点数据的版本号")])]),t._v(" "),a("h4",{attrs:{id:"事件监听-主动通知客户端获取锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件监听-主动通知客户端获取锁"}},[t._v("#")]),t._v(" 事件监听：主动通知客户端获取锁")]),t._v(" "),a("p",[t._v("客户端和zk服务端通信使用"),a("strong",[t._v("长连接")]),t._v("，在读取数据时，我们可以同时对节点设置事件监听，当节点数据或结构变化时，zookeeper会通知客户端。当前zookeeper有如下四种事件：")]),t._v(" "),a("p",[t._v("1）节点创建；2）节点删除；3）节点数据修改；4）子节点变更。")]),t._v(" "),a("h3",{attrs:{id:"加锁流程-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加锁流程-2"}},[t._v("#")]),t._v(" 加锁流程")]),t._v(" "),a("p",[t._v("如果zk中不存在对应锁节点，创建一个临时节点"),a("code",[t._v("/lock/my_lock")]),t._v("（来表示这个锁状态信息）,并且在这个临时节点下创建一个有序子节点 "),a("code",[t._v("192.168.11.1-10JQKA-lock-000001")]),t._v("（结尾表示有序节点的序号，前面表示锁持有者的身份信息）。此时，这个有序节点"),a("code",[t._v("192.168.11.1-10JQKA-lock-000001")]),t._v("为"),a("code",[t._v("/lock/my_lock")]),t._v("下的"),a("strong",[t._v("第一个有序节点，获取锁权限")])]),t._v(" "),a("p",[t._v("客户端获取锁权限后，完成业务操作（正常解锁）或抛出异常（于zk断开连接），都会删除临时有序节点"),a("code",[t._v("192.168.11.1-10JQKA-lock-000001")])]),t._v(" "),a("p",[a("img",{attrs:{src:_(586),alt:"1544271671971"}})]),t._v(" "),a("p",[t._v("如果zk中存在对应锁节点，查看该节点下的有序节点，如果为空，直接创建有序节点；如果不为空，在追加创建一个有序节点"),a("code",[t._v("192.168.11.3-78910J-lock-000002")]),t._v(",并且"),a("strong",[t._v("监听前一个节点的删除事件")]),t._v("，当监听到前一个节点被删除，就说明自己是有序节点中的第一个，获取锁权限")]),t._v(" "),a("p",[a("img",{attrs:{src:_(587),alt:"1544273434894"}})]),t._v(" "),a("h3",{attrs:{id:"重入锁-添加有序子节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重入锁-添加有序子节点"}},[t._v("#")]),t._v(" 重入锁（添加有序子节点）")]),t._v(" "),a("p",[t._v("只用在上面的基础上再加一层有序节点，加锁和解锁是对下一级有序节点进行操作，类似栈的操作（先加的锁先解）")]),t._v(" "),a("p",[t._v("当"),a("code",[t._v("192.168.11.1-10JQKA-lock-000001")]),t._v("下层有序节点为空时，删除改节点-解锁")]),t._v(" "),a("p",[a("img",{attrs:{src:_(588),alt:"1544276396033"}})]),t._v(" "),a("blockquote",[a("p",[t._v("扩展")]),t._v(" "),a("ul",[a("li",[t._v("开源框架 "),a("strong",[t._v("Curator")])])])])])}),[],!1,null,null,null);v.default=e.exports}}]);