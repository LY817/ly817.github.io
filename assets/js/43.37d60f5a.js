(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{645:function(t,v,_){"use strict";_.r(v);var a=_(21),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"what-is-reactive"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#what-is-reactive"}},[t._v("#")]),t._v(" What is Reactive?")]),t._v(" "),_("p",[t._v("被用在许多以高效著称的项目中，比如redis、nginx还有netty。")]),t._v(" "),_("p",[t._v("Java中，Rxjava是java语言中响应式编程模式最早的实现，用于安卓开发（在传GUI应用中因为不能阻塞 "),_("code",[t._v("绘图IO")]),t._v(" 所以有很多基于事件的编程模式）。")]),t._v(" "),_("p",[t._v("后来出现的projectreactor提供了更为完善的响应式编程API，让用户在异步编程的过程中能"),_("strong",[t._v("专注于那些定义业务逻辑的事件的依存关系")]),t._v("，而无需摆弄大量的线程相关实现细节。")]),t._v(" "),_("p",[t._v("使用响应式编程范式编写的代码逻辑实际上是"),_("strong",[t._v("声明回调事件的处理流程（管道）")]),t._v("，或者说定义了不同的事件执行对应的回调钩子函数。根据事件流中不同的事件，执行不同的回调，然后将执行结果发布到事件流中，由管道下游继续消费处理。")]),t._v(" "),_("p",[t._v("响应式是一种线程模型，本质上是"),_("strong",[t._v("观察者模式")]),t._v("，projectreactor中观察者设计模式的实现下一篇文章详细说。")]),t._v(" "),_("h1",{attrs:{id:"why-reactive"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#why-reactive"}},[t._v("#")]),t._v(" Why Reactive?")]),t._v(" "),_("h2",{attrs:{id:"解决并发场景痛点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解决并发场景痛点"}},[t._v("#")]),t._v(" 解决并发场景痛点")]),t._v(" "),_("p",[t._v("面对高并发场景，多线程作为常用的应对手段，来提高计算资源的利用率。")]),t._v(" "),_("p",[t._v("在Java中通常使用"),_("strong",[t._v("提交任务给线程池执行")]),t._v("的方式来实现多线程并行处理。")]),t._v(" "),_("p",[t._v("如果想要"),_("strong",[t._v("实现细粒度的异步操作")]),t._v("，将有互相依赖关系逻辑异步化，拆分为多个并行任务，则需要使用"),_("strong",[t._v("回调")]),t._v("函数或者通过feture阻塞获取返回结果来实现。")]),t._v(" "),_("p",[t._v("以上提到的两种方式都存在问题")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("Feture")]),t._v('：通过提交任务时返回的“凭证”或者”句柄"，在需要任务结果时，'),_("strong",[t._v("阻塞")]),t._v("地获取任务的返回结果，会导致维护逻辑关系的线程处于阻塞状态。")]),t._v(" "),_("li",[_("strong",[t._v("Callbacks")]),t._v("：使用回调函数的方式，可以避免阻塞\n但对于复杂的业务逻辑，会需要实现多个callback匿名函数，甚至多层回调函数嵌套。\njava作为一个“啰嗦”的语言，大量的匿名函数会使"),_("strong",[t._v("代码量急剧膨胀")]),t._v("。\n代码的可读性和可维护性都变低，对开发人员不友好，这就是所谓的“回调地狱”。")])]),t._v(" "),_("blockquote",[_("p",[t._v("Java8中，CompletableFuture的get 方法，像调用同步方法那样等待调用的方法执行结束并获得返回值；也可以像异步回调的方式一样，调用 CompletableFuture 那些以 then 开头的一系列方法，为 CompletableFuture 定义异步方法结束之后的后续操作")])]),t._v(" "),_("h2",{attrs:{id:"编程范式对比"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#编程范式对比"}},[t._v("#")]),t._v(" 编程范式对比")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("old style")]),t._v(" "),_("th",[t._v("reactor style")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("面向过程/对象")]),t._v(" "),_("td",[t._v("面向事件")])]),t._v(" "),_("tr",[_("td",[t._v("请求-响应")]),t._v(" "),_("td",[t._v("发布-订阅")])]),t._v(" "),_("tr",[_("td",[t._v("指令式编程  Declarative")]),t._v(" "),_("td",[t._v("声明式编程  Imperative"),_("br"),t._v("响应式编程 Reactive"),_("br"),t._v("响应式是声明式的延伸")])])])]),t._v(" "),_("p",[t._v("Old stype即进行一次调用，期望得到这次调用的结果。这种模式符合开发者直觉，也更加贴近计算机的运算硬件面向过程的设计。但是不适合编写复杂的并行程序，不适合异步多线程并发的使用环境。")]),t._v(" "),_("p",[t._v("取而代之的是"),_("strong",[t._v("面向事件")]),t._v("、基于"),_("strong",[t._v("发布-订阅")]),t._v("模式的响应式编程。")]),t._v(" "),_("p",[t._v("响应式模式本质上还是通过回调实现的。区别在于"),_("strong",[t._v("面向的事件源")]),t._v("而不是面向对象（传入函数对象），解耦了并发控制逻辑和业务逻辑，并且以更易于理解的方式编写异步逻辑。")]),t._v(" "),_("blockquote",[_("p",[t._v("参考")]),t._v(" "),_("p",[t._v("http://blog.yannxia.top/2018/06/26/java/spring/projectreactor/")]),t._v(" "),_("p",[t._v("https://blog.csdn.net/qq_41737716/article/details/105913665")]),t._v(" "),_("p",[t._v("https://www.imooc.com/article/46306")])])])}),[],!1,null,null,null);v.default=e.exports}}]);