# TCP三次握手

三次握手是为了建立一个可靠的连接，而建立可靠连接的前提是**服务端和客户端互相知道对方的序列号**

![1552365118406](assets\1552365118406.png)

## 第一次握手	【客户端 ==SYN=> 服务端】

建立连接，客户端发送`SYN`(**seq=x** 正整数序列号)包到服务器，并进入**SYN-SENT**状态，**等待服务端确认**；服务端收到客户端的SYN包

> 客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c) （示意图中x）

SYN：服务端的数据包的序列号

**客户端角度**

- [ ] 自己知道对端的序列号
- [ ] 对端知道自己的序列号
- [ ] 客户端发送能力
- [ ] 客户端接收能力
- [ ] 服务端发送能力
- [ ] 服务端接收能力

**服务端角度**

- [ ] 自己知道对端的序列号
- [ ] 对端知道自己的序列号
- [x] 客户端发送能力
- [ ] 客户端接收能力
- [ ] 服务端发送能力
- [x] 服务端接收能力

客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。

## 第二次握手	【客户端 <=SYN+ACK== 服务端】

> 服务端发送自己的SYN段作为应答，同样指明自己的ISN(s) （示意图中y）
>
> 为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。

SYN：服务端的数据包的序列号

ACK：客户端SYN包中的序列号+1

**客户端角度**

- [x] 自己知道对端的序列号
- [x] 对端知道自己的序列号

- [x] 客户端发送能力
- [x] 客户端接收能力
- [x] 服务端发送能力
- [x] 服务端接收能力

**服务端角度**

- [x] 自己知道对端的序列号
- [ ] 对端知道自己的序列号

- [x] 客户端发送能力
- [ ] 客户端接收能力
- [ ] 服务端发送能力
- [x] 服务端接收能力

这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。

从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。

## 第三次握手	【客户端 ==ACK=> 服务端】

客户端收到服务端的SYN+ACK后，向服务端发送确认包`ACK`（seq=y+1），发送完成，客户端进入ESTABLISHED状态

服务端收到ACK包验证通过后，服务端也进入ESTABLISHED状态，可以进行双向的数据传输

ACK：服务端SYN包中的序列号+1

**客户端角度**

- [x] 自己知道对端的序列号
- [x] 对端知道自己的序列号

- [x] 客户端发送能力
- [x] 客户端接收能力
- [x] 服务端发送能力
- [x] 服务端接收能力

**服务端角度**

- [x] 自己知道对端的序列号
- [x] 对端知道自己的序列号

- [x] 客户端发送能力
- [x] 客户端接收能力
- [x] 服务端发送能力
- [x] 服务端接收能力

这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。

 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。

# 总结

## WHY 3

1. **为了初始化双方包序号** 并互相告知
2. 验证双方网络的收发能力

握手完成之后，每发送一个SYN，序列号就会在起始值的基础上加1. 如果有丢失的情况，则会重传

## SYN+ACK

**SYN**中的seq number为这次TCP连接序列号的起始值：告诉对方，我方序列号的起始值

**ACK**中的seq number为起始值+1：为了告知对方，已经得知对方的seq number

## 问题：SYN超时

第三次握手失败，TCP连接处于中间状态（既没有成功有没有失败），服务端会**不断重试**第二次握手操作（发送SYN+ACK）给客户端。Linux默认63秒后才会判断为失败（重试的间隔时间每次都翻倍，重试6次 63=1+2+4+8+16+32）

### 基于此的网络攻击：SYN Flood

恶意程序不断给服务端发送SYN报文然后下线，耗尽服务器的**SYN连接队列资源**

##### 解决方法

在Linux下，当SYN对列满后，通过tcp_syncookies参数会发SYN

## 问题：客户端故障

向对方发送**保活探测报文**，如果未收到响应则继续发送（一定间隔和次数），达到**保活探测次数上限**，则判定对端网络不可达，则中断连接
