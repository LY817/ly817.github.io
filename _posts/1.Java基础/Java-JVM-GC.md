GC发生在堆上

堆内存空间有限

# 对象GC标准

## 可达性分析算法

用来在GC时判断对象是否需要回收

在JVM中会设立若干种根对象(GC Roots)，当任何一个根对象到某一个对象均不可达（没有**引用关系**）时，则认为这个对象是可以被回收的

- 方法栈中的局部变量

  > 被正在执行的方法引用

- 静态变量

### 引用类型

#### 强引用

被强引用的对象，不会被垃圾回收

##### 用法

普通的等号赋值，没有其他修饰

#### 软引用

正常情况下垃圾回收是不会回收软引用，**如果垃圾回收之后，内存空间还是不足以存放新的对象，就会把软引用的对象回收**

##### 用法

```java
public static SoftReference<Object> ref = new SoftReference<Object>(new Object());
```

#### 弱引用

发生垃圾回收时，被弱引用的对象和不可达的对象一样，会被垃圾回收

##### 用法

```java
public static WeakReference<Object> ref = new WeakReference<Object>(new Object());
```



# GC类型

## 发生区域划分

### Minor GC

又称为Young GC，发生在堆区新生代

#### 触发条件

当新生代（Eden区和From Space）的内存空间不足，则会触发Minor GC

### Major GC

发生在老年代中的GC

## 算法划分

### Serial GC

`-XX:+UseSerialGC`
它是最古老的垃圾收集器，“Serial”体现在其收集工作是**单线程**的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World” 状态。当然，其单线程设计也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下JVM的默认选项。
从年代的角度，通常将其老年代实现单独称作Serial Old，它采用了标记-整理（Mark-Compact）算法，区别于新生代的复制算法。

### ParNew GC

`-XX:+UseParNewGC`
是个新生代GC实现，它实际是Serial GC的**多线程**版本，最常见的应用场景是配合老年代的CMS GC工作

### CMS（Concurrent Mark Sweep） GC

> 老年代GC算法
>
> 特点
>
> - 标记-清除 有是碎片
> - 减少"Stop the World"

`-XX:+UseConcMarkSweepGC`
基于**标记-清除**（Mark-Sweep）算法，设计目标是**尽量减少停顿时间**，这一点对于Web等反应时间敏感的应用非常重要
但是，CMS采用的标记-清除算法，**存在着内存碎片化问题**，所以难以避免在长时间运行等情况下发生full GC，导致恶劣的停顿。另外，强调了并发（Concurrent），垃圾回收线程与系统工作线程**尽量同时执行**，所以CMS会占用更多CPU资源，并和用户线程争抢CPU资源。

#### 实现过程

##### 初始标记

会让系统线程全部停止，进入"Stop the World"，标记出所有GC Roots**直接引用**的对象

##### 并发标记

退出"Stop the World"，让系统工作线程继续开始工作，对所有的对象进行GC Roots跟踪，找到老年代中所有被GC Roots引用的对象

在此过程中可能会创建新的存活对象，也可能会有部分存货对象失去引用，变成垃圾对象。垃圾回收线程会尽量的对已有的对象进行**GC Roots追踪**

##### 重新标记

再次进入"Stop the World"，对并发标记阶段中系统运行变动过的少数对象进行标记

##### 并发清理

退出"Stop the World"，开始清理被标记为垃圾的对象

### Parrallel GC

`-XX:+UseParallelGC`
在早期JDK 8等版本中，它是server模式JVM的默认GC选择，也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂的多，其特点是新生代和老年代GC都是并行进行的，在常见的服务器环境中更加高效。

### G1 GC

种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。G1可以直观的设定停顿时间的目标，相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

# GC算法

## 复制算法

> 优点：避免内存碎片化
>
> 缺点：进行复制，既要提前预留内存空间，有一定的**空间浪费**

新生代GC基于复制算法
将Eden和Survivor0（from区域）中存活的对象复制到to区域（survivor1），拷贝过程中将对象顺序放置，就可以避免内存碎片化，提高内存的利用率

### 晋升老年代

#### “年龄”到达阈值

复制一次对象的年龄计数器+1，当年龄计数器到达阈值，会被晋升到老年代
阈值设置参数：`-XX:MaxTenuringThreshold=<N>` 默认阈值为15

##### 动态对象年龄判断

当Survivor区中的对象的总大小超过总内存大小的50%，会将“年龄”大于等于**这批对象中最大年龄**的对象移到老年代

#### 超大对象

当需要创建超大的对象，在新生代中没有足够的连续内存来存放

阈值设置参数：`-XX:PretenureSizeThreshold`

#### “幸存”对象大小超过Survivor容量

Minor GC后幸存的对象的总大小大于一个Survivor区的容量，这回把这些对象直接复制到老年代

## 标记-整理(压缩)算法 Mark-Compact

> 老年代GC算法
>
> 优点：避免内存碎片化
>
> 缺点：效率不高

类似于标记-清除，但为避免内存碎片化，它会在清理过程中**将对象移动**，以确保移动后的对象占用连续的内存空间

## 标记-清除算法 Mark-Sweep

> 老年代GC算法
>
> 优点：效率较高
>
> 缺点：内存碎片化

首先进行标记工作，标识出所有要回收的对象，然后进行清除。

> 这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现Full GC，暂停时间可能根本无法接受

# GC执行流程



