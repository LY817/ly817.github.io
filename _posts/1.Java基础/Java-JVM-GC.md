GC发生在堆上

堆内存空间有限

出发条件

# GC类型

## 发生区域划分

### Minor GC

又称为Young GC，发生在堆区新生代

#### 触发条件

当新生代（Eden区和From Space）的内存空间不足，则会触发Minor GC

### Major GC



## 算法划分

### Serial GC

`-XX:+UseSerialGC`
它是最古老的垃圾收集器，“Serial”体现在其收集工作是**单线程**的，并且在进行垃圾收集过程中，会进入臭名昭著的“Stop-The-World” 状态。当然，其单线程设计也意味着精简的GC实现，无需维护复杂的数据结构，初始化也简单，所以一直是Client模式下JVM的默认选项。
从年代的角度，通常将其老年代实现单独称作Serial Old，它采用了标记-整理（Mark-Compact）算法，区别于新生代的复制算法。

### ParNew GC

`-XX:+UseParNewGC`
是个新生代GC实现，它实际是Serial GC的多线程版本，最常见的应用场景是配合老年代的CMS GC工作

### CMS（Concurrent Mark Sweep） GC

`-XX:+UseConcMarkSweepGC`
基于**标记-清除**（Mark-Sweep）算法，设计目标是尽量减少停顿时间，这一点对于Web等反应时间敏感的应用非常重要
但是，CMS采用的标记-清除算法，**存在着内存碎片化问题**，所以难以避免在长时间运行等情况下发生full GC，导致恶劣的停顿。另外，既然强调了并发（Concurrent），CMS会占用更多CPU资源，并和用户线程争抢。

### Parrallel GC

`-XX:+UseParallelGC`
在早期JDK 8等版本中，它是server模式JVM的默认GC选择，也被称作是吞吐量优先的GC。它的算法和Serial GC比较相似，尽管实现要复杂的多，其特点是新生代和老年代GC都是并行进行的，在常见的服务器环境中更加高效。

### G1 GC

种兼顾吞吐量和停顿时间的GC实现，是Oracle JDK 9以后的默认GC选项。G1可以直观的设定停顿时间的目标，相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多。

# 算法

## 复制算法

> 优点：避免内存碎片化
>
> 缺点：进行复制，既要提前预留内存空间，有一定的**空间浪费**

新生代GC基于复制算法
将Eden和Survivor0（from区域）中存活的对象复制到to区域（survivor1），拷贝过程中将对象顺序放置，就可以避免内存碎片化；
复制一次对象的年龄计数器+1，当年龄计数器到达阈值，会被晋升到老年代；
阈值设置命令：`-XX:MaxTenuringThreshold=<N>`

## 标记-整理(压缩)算法 Mark-Compact

> 优点：避免碎片化
>
> 缺点：

类似于标记-清除，但为避免内存碎片化，它会在清理过程中将对象移动，以确保移动后的对象占用连续的内存空间

## 标记-清除算法 Mark-Sweep

首先进行标记工作，标识出所有要回收的对象，然后进行清除。

> 这么做除了标记、清除过程效率有限，另外就是不可避免的出现碎片化问题，这就导致其不适合特别大的堆；否则，一旦出现Full GC，暂停时间可能根本无法接受