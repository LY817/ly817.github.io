---
layout: post
title: JVM虚拟机
tags:
- Java基础
date: 2019-12-01 20:33:14
permalink:
categories:
description:
keywords:
---



# JVM数据区域

> JVM内存模型区别于Java内存模型JMM

JVM**运行时**数据区域划分

- 线程共享
  - 堆
  - 方法区
    - 运行时常量池
- 线程独占
  - 虚拟机栈
  - 本地方法栈
  - 程序计数器

![img](assets\908514-20160728195713028-1922699910.jpg)



## 线程共享

### 方法区 Method Area

方法区属于线程共享的内存区域，又称Non-Heap（非堆），主要用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据

> #### 永久代 PermGem
>
> java8之前方法区称为永久代，Java8之后被废除，替换为Metaspace(本地内存中) 
>
> - PermGem有大小限制，当JVM中动态代理生成太多class对象，就会抛出` java.lang.OutOfMemoryError:PermGenspace `
>
> - Metaspace不在JVM中，不受JVM的内存大小限制

####  运行时常量池（Run-Time Constant Pool） 

方法区的一部分。Java的常量池可以存放各种常量信息，不管是编译期生成的各种字面量，还是需要在运行时决定的符号引用，所以它比一般语言的符号表存储的信息更加宽泛。
程序运行期间，静态存储的数据将随时等候调用。可用`static关键字`指出一个对象的特定元素是静态的。但Java对象本身永远都不会置入静态存储空间。 



### 堆 Heap

Java内存管理的核心区域，用来放置Java对象实例，几乎所有创建的Java对象实例都是被直接分配在堆上。堆被**所有的线程共享** 

#### 新生代 NewGen

年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1 

##### Eden 伊甸园

绝大多数新建的对象都“出生在”Eden ，占用内存很大的对象，会被直接在老年代创建

> 代码的写法会决定对象的声明周期，要根据不同的场景选择
>
> - 在方法中new出来的对象，当方法执行完毕之后，就会失去引用，被垃圾回收
> - 被定义为类的静态变量，其引用一直存在方法区的常量池中，不会被垃圾回收，经过几次GC后进入老年代

##### Survivor 幸存者

分为两个大小相同的区域，称为FromSpace和ToSpace。用来放置Minor GC复制-清除算法存活下来的对象

> 用于复制-清除算法，为了解决碎片化。

#### 老年代 OldGen

放置长生命周期的对象，通常都是从Survivor区域拷贝过来的对象（Survivor区存活了）；也可能是占用内存很大的对象，在创建的时候被直接放到老年代； 

#### 相关启动参数

> - `-Xmx value` 最大堆体积
> - `-Xms value` 初始的最小堆体积
> - `-XX:NewRatio=value` 老年代和新生代的比例
>   默认情况下，这个数值是3，意味着老年代是新生代的3倍大；换句话说，新生代是堆大小的1/4。
> - `-XX:NewSize=value` 新生代大小
>   可以不用比例的方式调整新生代的大小，直接指定下面的参数，设定具体的内存大小数值
> - `-XX:SurvivorRatio=value`
>   Eden和Survivor的大小是按照比例设置的，如果SurvivorRatio是8，那么Survivor区域就是Eden的1/8大小，也就是新生代的1/10，因为YoungGen=Eden + 2*Survivor

## 线程私有

每启动一个**线程**都会给线程分配一块内存区域来存储程序计数器和方法调用栈

### 程序计数器（PC，Program Counter Register）

指向线程当前方法**正在执行**的**字节码指令**(存放在Class对象的方法属性中)

> 每个线程都有它自己的程序计数器，并且任何时间一个线程都只有一个方法在执行，也就是所谓的**当前方法**
>
> 程序计数器会存储当前线程正在执行的Java方法的JVM指令地址；或者，如果是在执行native方法，则是未指定值（undefined） 

#### 作用

线程是一个抽象概念，CPU的计算资源会在多个线程间切换，当线程让出计算资源时，线程会进入挂起状态；当线程再次获得计算资源，线程会读取程序计数器指向的JVM指令继续执行

当CPU资源在多个线程间换时，程序计数器和虚拟机栈用来**保存线程执行的上下文**

### Java虚拟机栈（Java Virtual Machine Stack）

每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用

#### 栈帧（Stack Frame）

栈帧（Stack Frame） 是用于虚拟机执行时方法调用和方法执行时的数据结构，是虚拟栈数据区的组成元素。每一个方法从调用到方法返回都对应着一个栈帧入栈出栈的过程。

> 我的理解
>
> - 这里的方法调用指的是JVM指令（class文件通过javap反编译）
> - 栈帧是线程执行JVM指令的“上下文”
> - java主线程的方法调用栈的**最底部**为java入口函数（main方法）；子线程的方法调用栈的最底部为run方法
> - 虚拟机栈的最顶是线程当期正在执行的方法

##### 栈帧结构

- 局部变量表 Local Variable Table

  存放方法参数和方法内部定义的局部变量

  - 为一组变量值存储空间，用于存放方法参数和方法内定义的局部变量。

  - 最小单位变量槽（Variable Slot），可以存放boolean、byte、char、short、int、float、reference、returnAddress8中数据类型。 

- 操作栈 Operand Stack

  也为操作栈，为后入先出LIFO结构，就是方法执行过程中，会有各种字节码指令往操作栈中写入和提取内容，即入栈、出栈操作。举个最简单例子：a=b+c*d，大家可以想象一下过程

- 动态连接 Dynamic Linking

  每个栈帧都包含一个执行运行时常量池中该栈帧所属方法的引用，支持方法调用过程的动态链接。

- 返回地址

  - 正常返回，遇到方法返回的字节码指令，返回值传递给上层的方法调用者。也就是程序的正常执行返回。
  
  - 异常返回，程序执行遇到异常，返回的

<img src="assets\592743-20160321201532464-1956190499.png" alt="img"  />  


### 本地方法栈（Native Method Stack） 

本地方法栈属于线程私有的数据区域，这部分主要**与虚拟机用到的 Native 方法相关**，一般情况下，我们无需关心此区域。

# 执行引擎

执行引擎从方法区中一条一条的读取并执行方法调用指令

方法区中读取的方法调用指令需要经过解析才能被执行引擎执行

![img](E:\blog\_posts\1.Java基础\assets\u=390929530,1299465342&fm=173&app=25&f=JPEG.jpg)

### 解析（Resolution）调用

特点：是静态过程；在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，而不会延迟到运行期再去完成，即**编译期可知、运行期不可变**

适用对象：静态方法（与类型直接关联）、私有方法（在外部不可被访问），它们都不可能通过继承或其他方式重写其他版本

### 分派（Dispatch）调用



## 字节码指令