---
layout: post
title: MySQL事务
tags:
- MySQL
- 事务
date: 2019-10-31 20:33:14
permalink:
categories:
description:
keywords:
---
事务是**一组**数据操作的集合，是一组程序的执行单元

# 事务特性 ACID

事务本身不包含这4个特性，我们需要通过某些手段，尽量的让执行单元满足这四个特性

## 原子性 - Atomic

事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行

> 通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性

## 一致性 - Consistency

事务可以**封装状态改变**,事务必须始终保持**系统**处于一致的状态，不能破坏关系数据的完整性以及**业务逻辑**上的一致性。

在一个事务执行之**前**和执行之**后**数据库都必须处于一致性状态。这种特性称为事务的一致性

> 比如 转账业务 扣款账户减少的金额和到款账户增加的金额必须一致

## 隔离性 - Isolation

在**并发**环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自完整的数据空间

事务是并发控制机制，他们交错使用时也能提供一致性。隔离让我们隐藏来自外部世界未提交的状态变化，一个失败的事务不应该破坏系统的状态。隔离是通过用悲观或乐观锁机制实现的。

## 持久性 - Durability

事务结束后，事务处理的结果必须能够得到固化，即写入数据库文件中即使机器宕机数据也不会丢失，它对于系统的影响是永久性的

> 事务机制的实现处于**存储引擎磁盘数据操作之前**。所有已提交的事务都会被**持久化到事务日志**中
>
> 对于已提交但未通过存储引擎写入磁盘的事务，就算MySQL服务宕机重启，已提交事务的修改依然会被持久化到磁盘

# 隔离级别

隔离级别的引入是为了**解决并发场景下的数据异常**

数据的隔离性和并发性能存在**矛盾**，隔离性越高意味着并发性能越低。所以隔离级别的选择需要根据业务场景权衡

## 数据异常类型

### 更新丢失

#### 第一类丢失更新（Update Lost）

此种更新丢失是因为回滚的原因，所以也叫**回滚丢失**

> 此时两个事务同时更新count，两个事务都读取到100，事务一更新成功并提交，count=100+1=101，事务二出于某种原因更新失败了，然后回滚，事务二就把count还原为它一开始读到的100，此时事务一的更新就这样丢失了

#### 第二类丢失更新（Second Update Lost）

此种更新丢失是因为更新被其他事务给覆盖了，也可以叫**覆盖丢失**

> 两个事务同时更新count，都读取100这个初始值，事务一先更新成功并提交，count=100+1=101，事务二后更新成功并提交，count=100+1=101,由于事务二count还是从100开始增加，事务一的更新就这样丢失了

### 脏读（Dirty Read）

此种异常时因为一个事务读取了另一个事务**修改了但是未提交的数据**

可以在READ-COMMITTED事务隔离级别以上可以避免

### 不可重复读（Not Repeatable Read）

此种异常是一个事务对同一行数据执行了两次或更多次查询（**update和delete**），但是却得到了不同的结果，也就是在一个事务里面你不能重复（即多次）读取一行数据，如果你这么做了，**不能保证每次读取的结果是一样的**，有可能一样有可能不一样。因为在两次查询之间有别的事务对该行数据做了更新操作

**Repeatable Read隔离级别可以避免**

### 幻读（Phantom Read）

幻读和不可重复读有点类似，只是针对的不是数据字段的值而是数据的条数（**insert**）。此种异常是一个事务在两次查询的过程中数据的数量不同，让人以为发生幻觉，幻读大概就是这么得来的吧。举个例子，事务一查询order表有多少条记录，事务二新增了一条记录，然后事务一查了一下order表有多少记录，发现和第一次不一样，这就是幻读

**Serializable隔离级别可以避免**

## 解决矛盾 - 隔离级别

为了权衡『隔离』和『并发』的矛盾，ISO定义了4个事务隔离级别，每个级别隔离程度不同，允许出现的副作用也不同

## 隔离级别对各异常的控制能力

Y-会发生该异常，N-可以避免该异常

| 级别\异常 | 第一类更新丢失 | 脏读 | 不可重复读 | 第二类丢失更新 | 幻读 |
| --------- | -------------- | ---- | ---------- | -------------- | ---- |
| 读未提交  | Y              | Y    | Y          | Y              | Y    |
| 读已提交  | N              | N    | Y          | Y              | Y    |
| 可重复读  | N              | N    | N          | N              | Y    |
| 串行化    | N              | N    | N          | N              | N    |

### 读未提交（Read Uncommitted）

即使一个事务的更新语句没有提交,但是别的事务可以读到这个改变

> 几种异常情况都可能出现。极易出错，没有安全性可言，基本不会使用

### 读已提交（Read Committed）

**一个事务只能看到其他事务的已经提交的更新**，看不到未提交的更新

> 消除了脏读和第一类丢失更新，这是大多数数据库的默认隔离级别，如Oracle,Sqlserver

### 可重复读（Repeatable Read）

一个事务中进行两次或**多次**同样的对于数据内容的**查询**，得到的**结果**是**一样**的

但不保证对于数据**条数**的查询是一样的，只要存在读改行数据就禁止写

> 消除了不可重复读和第二类更新丢失，这是Mysql数据库的默认隔离级别
>
> **事务之间update操作不透明，但可以看到insert和delete对数据条数的改变**

> MySQL的innodb可以在Repeatable Read的隔离级别下避免幻读
>
> > 当前读与快照读
> >
> > - 当前读：加锁的select和增删改 
> >
> > - 快照读：不加锁的非阻塞读：select
> >
> >   可能读到的数据不是数据的最新版本



### 串行化（Serializable）

这个事务执行的时候不允许别的事务并发执行，完全串行化的读，只要存在读就禁止写,但可以同时读，消除了幻读

> 这是事务隔离的最高级别，虽然最安全最省心，但是效率太低，一般不会用

# 事务设置

## MySQL设置

默认情况下,MySQL启用自动提交模式（变量autocommit为ON）

在命令行执行sql语句的时候，每执行一行语句并执行实质上后面接了一句commit，就是完成了一次事务

### 关闭自动提交

修改当前实例事务提交设置 `set global autocommit=0;`

修改配置文件 `autocommit=0`

### 使用显式事务提交

在**关闭自动提交模式（关闭隐式提交）的情况**下，开启一个事务上下文。首先数据库会隐式提交之前的还未被提交的操作，同时开启一个新事务。

使用start transaction或begin开启一个事务

### 设置事务隔离级别

当前实例/session配置

```sql
SET 
[SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL 
[READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE]
```

mysql配置

```
– READ-UNCOMMITTED
– READ-COMMITTED
– REPEATABLE-READ
– SERIALIZABLE

[mysqld]
transaction-isolation = READ-COMMITTED
```

查询事务隔离级别

```sql
SELECT @@global.tx_isolation; 
SELECT @@session.tx_isolation; 
SELECT @@tx_isolation;
```

### 事务控制语句

事务开始 `begin或start transaction`

事务提交 `commit或commit work`

回滚 `rollback或rollback work`

保存点设置 `savepoint point1`

回滚到保存点 `rollback to savepoint point1`

删除保存点 `release savepoint point1`