# 概述

滑动窗口实现了TCP**流量控制**。

首先明确滑动窗口的范畴：TCP是**双工**的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方**都各自维护一个`发送窗口`和一个`接收窗口`**。

两端的**`接收窗口`大小**取决于**应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）**

两端的**`发送窗口`大小**则要求取决于**对端**通告的**接收窗口**，要求**相同**

> 滑动窗口解决的是**流量控制**的问题，就是如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。
>
> 接收端的**缓存**传输数据给应用层，但这个过程不一定是即时的，如果发送速度太快，会出现接收端数据overflow（接收端的缓存溢出），流量控制解决的是这个问题
>
> 关键词：双工 缓存  数据包

#### 数据包&ACK

TCP连接是**通过数据包和ACK实现的**，我们作为第三者可以看到双方发包的过程，但接受者在收到之前不知道发送方发的是什么，同样的，发送方在收到ACK前也不知道对方是否成功接收。

发送方没有收到接收方发回的ACK，就不能向右滑动。假设发送方向接收方发了ABCD就滑动，只要对方没收到A，就不能滑动，那么就会出现二者不同步的局面（发送窗口由最左边是否收到ACK觉得是否滑动）

#### 信道利用率

滑动窗口**提高了信道利用率**

TCP是发送**报文段**为单位的，假如每发一个报文就要等上一个包的ACK，那么对于大数据包，等待时间就太长了。

只要发送的报文在滑动窗口里面，不用等每个ACK回来就可以向右滑动。本例中，开始接收端空着AB，只有CD，此时不能滑动；之后接收到EF和H，直接向右滑动2位，不必等G到位。

> 滑动窗口机制可以运行多个数据包同时发送，给每个ACK更加“宽松”的接收等待时间

#### 窗口宽度

窗口大小不能大于序号空间大小的一半。目的是为了不让两个窗口出现交迭，比如总大小为7，窗口大小都为4，接收窗口应当滑动4，但只剩3个序号，导致两个窗口交迭。

有一种情况没出现：发送方发ABCD，接收方都收到然后向右滑动，但回复的ACK包全丢了。发送方未收到任何ACK， timeout后会重发ABCD，此时的接收方按累计确认的原则，收到ABCD后只会重发D的ACK，发送方收到后向右滑动。

### RTT&RTO

#### RTT 

发送端从发送一个数据包到收到返回的ACK,所花费的时间

#### RTO 重传间隔

# 窗口的概念

窗口表示，在传输缓存区中，允许处于发送中状态的数据包个数

发送方的发送缓存内的数据都可以被分为4类: 

* ①已发送，已收到ACK  
* ②已发送，未收到ACK  （发送窗口）
* ③未发送，但允许发送 （发送窗口） 
* ④未发送，但不允许发送

> 其中②和③的数据包处于发送中状态

接收方的缓存数据分为3类： 

* ①已接收
* ②未接收，但接收准备就绪（接收窗口）
* ③未接受，接收准备未就绪



## 窗口大小

窗口大小代表了设备一次能从对端处理多少数据，之后再传给应用层。缓存传给应用层的数据不能是乱序的，窗口机制保证了这一点。现实中，应用层可能无法立刻从缓存中读取数据

## 滑动机制

1. 发送窗口只有收到发送窗口内字节的ACK确认（即② > ①时），才会移动发送窗口的左边界

2. 接收窗口只有在前面所有的段都确认的情况下（即② > ①时）才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。

3. 遵循快速重传、累计确认、选择确认等规则。

4. 发送方发的window size = 8192;就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。

## 示意图

下列示意图描述了不同场景下的窗口滑动情况

> 1.（丢包）
>
> 首先发送端发送A,B,C,D四个包，但是A,B丢失，只有C,D到达接收端

![img](assets\42138740462_ed4ce64c1b_b.jpg)

> 2.（重发）
>
> 接收端没有收到A，所以不回复ACK包。发送端重传A,B,C,D四个包，这次全都到达了

![img](assets\42138740402_dbbbf52c8c_b.jpg)

> 3.（接收窗口**全量**滑动）
>
> 接收端先获得A，发ACK包A，但是中途丢失；获得B后，根据**累计确认原则**，发D的ACK包，然后窗口滑动。再次获得C,D后，连续回复2个D的ACK包，其中C对应的ACK包丢失 
>
> **累计确认原则**：收到后面的ACK

![img](assets\27313728687_a5673da755_b.jpg)

> 4.（发送窗口**全量**滑动）
>
> 发送端连收2个D的ACK包，说明4个包对方都已收到，窗口滑动，发E,F,G,H包，其中G包丢失。现在整个序列的状态：ABCD是已发送已确认，EFGH是已发送未确认，I~S是不能发送。

![img](assets\27313728577_04e0867716_b.jpg)

> 5.（接收窗口**部分**滑动）
>
> 接收端先收到E，发ACK包；收到F后发F的ACK包；未收到G，还是发F的ACK包；收到H，还是发F的ACK包。不幸的是，三个ACK包全都丢失。 

![img](assets\27313728427_a5b7d4b107_b.jpg)

> 6.（发送窗口**部分**滑动）
>
> 发送端收到E的ACK包，窗口向右滑动一位；然后再发送F,G,H,I，其中F丢失

![img](assets\27313728297_65698014e9_b.jpg)

> 7.（）
>
> 接收端获得I，因为没有G，只好回复F的ACK包。相继收到G,H包

![img](assets\28312507728_96c5813bee_b.jpg)

> 8.
>
> 接收端根据累计确认，连发两个I包，其中H对应的丢失。窗口向右滑动

![img](assets\41284211495_31f906941b_b.jpg)

> 9.
>
> 发送端接收I的ACK包后，向右滑动四位。发送J,K,L,M四个包，后面不再分析

![img](assets\27313728077_b406cc3293_b.jpg)









