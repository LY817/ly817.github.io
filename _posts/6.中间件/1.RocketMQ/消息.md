### 消息常用设置

#### 延时消息

通过设置消息对象的DelayTimeLevel来设置消息的延时时间

`1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h`

从0开始

```java
Message.setDelayTimeLevel(int delayLevel)
```

#### 批量消息

send方法可以发送Message集合，发送批量消息。总大小小于4M

### Producer消息投递方式

> 设置Namesrv地址（集群模式使用“;”隔开）
>
> 指定投递到的topic

#### 同步消息

producer发送消息后进入阻塞状态，只有确定消息被broker正常接收（接收到broker正常接收的响应），才返回，进行后面的逻辑。

返回值中得到消息发送到服务端的相关情况

> 可靠性高，用来发送重要的消息通知

#### 异步消息

producer异步的发送消息给broker，发送线程发送后就返回

可以传入**回调函数**处理子线程发送消息的返回结果

> 通常用于响应时间敏感的业务场景

send方法中传入回调函数

```java
producer.send(msg,new SendCallback(){
    @Override
    pulic void onSuccess(SendResult sendResult){
        // balabala
    }
    @Override
    public void onException(Throwable e){
        // balabala
    }
});
```

#### 单向消息

producer发送单向消息后没有返回值，用于不关心发送结果的场景，比如日志

```java
// 该方法没有返回值
producer.sendOneway(msg);
```

### Consumer消息消费方式

> 定义Consumer类型（服务端推push或者客户端拉pull）
> 设置Namesrv地址（集群模式使用“;”隔开）
> 指定**订阅**的topic和tag过滤表达式
> 注册消息监听器，用来处理消费到的消息

#### pull模式和push模式

创建consumer实例时选择

#### 广播模式和负载均衡模式

在consumer设置中`setMessageModel`设置

- `MessageModel.CLUSTERING` 负载均衡模式（**默认**）
- `MessageModel.BROADCAST`广播模式

### 顺序消息

每一个topic有多个队列（默认4个）用来提高读写性能（使用多线程读写）

需要保证消息的顺序性时，只需要把需要保持顺序消息都投递到同一个队列（保证局部的顺序性）

#### Producer发送方式

```java
producer.send(msg,new MessageQueueSelector(){
    @Override
    pulic MessageQueue select(List<MessageQueue> mqs,Message msg,Object arg){
        // 自定义根据消息内容，将消息路由到指定的MessageQueue下
        // arg即为外层传的mark
        // 选做：从msg中取出信息，与arg比较验证
        // 如果比较满足条件，则将arg映射为mqs的下标 x，将对应的MessageQueue返回
        return mqs.get(x);
    }
},mark);
```

send方法的参数

1. msg：消息对象
2. MessageQueueSelector：自定义消息队列选择器 
3. mark：消息业务标识（例如订单号），用来判断消息是否为同一类（例如属于同一个订单的操作则通过选择器路由到同一个queue中来保证顺序）

#### Consumer接收方式

```java
consumer.registerMessageListener(
    new MessageListenerOrderly(){
        @Override
        pulic void consumeMessage(List<MessageExt> msgs,ConsumeOrderlyContext context){
            // balabala
        }
    }
);
```

区别于`MessageListenerConcurrently`，会**单线程**读取topic中的消息

> 问题：负载均衡模式下（多个consumer进程同时消费），如何保证顺序消息

### 消息过滤

消费消息前，可以通过**表达式**判断message的属性（tag和property）来筛选



在订阅时，通过subscribe方法添加过滤条件

#### subExpression

只能过滤tag

```java
// 在consumer订阅topic时，可以传入表达式，对消息的tag进行过
public void subscribe(String topic, String subExpression)；
```

#### MessageSelector

可以过滤tag和property

```java
public void subscribe(final String topic, final MessageSelector messageSelector)；    
```

MessageSelector提供两个static的方法，来构建MessageSelector

* bySql(String sql)
  * 对发送消息的自定义属性进行过滤
    * message.putUserProperty(name,value)
  * 表达式准许SQL92标准的SQL语法（mysql）
    - 数值比较：>,>=,<,<=,BETWEEN,=
    - 字符比较：=,<>,IN
    - 空值判断：IS NULL,IS NOT NULL
    - 逻辑符号：AND,OR,NOT
    - 数值：1,3.14
    - 字符：'a'（使用单引号包裹）
    - 布尔值：TRUE或FALSE
  * sql表达式中的变量即为property的name
* byTag(String expression)
  * `*` 表示接受所有tag
  * 使用 `||` 连接多个tag名称







