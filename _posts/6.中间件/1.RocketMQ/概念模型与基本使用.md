# 角色

## NameServer

用来管理集群里所有Broker的信，mq集群对外暴露服务之后NameServer

让MQ的客户端可以感知到集群里有哪些Broker

- 客户端会定时从NameServer拉取集群中所有的broker信息
- broker通过心跳机制 告知NameServer自己是否在线
  - 10s检查一次心跳状态 如果120s没有更新心跳 则表示该broker下线

> NameServer可以多台部署，采用peer to peer模式（类似Spring Cloud Eureka的注册中心），每一台都保存集群中所有broker信息
>
> 更加轻量级的实现，替代原来zookeeper注册中心

## Broker

提供消息队列服务的进程

## Topic

数据的逻辑划分 用来隔离不同的数据域

> 作为消息的一级标签，

#### MessageQueue

一个topic包含多个MessageQueue，用来；一个topic在创建时，可以设置包含多少个MessageQueue

> 数据分片机制
>
> topic下的多个MessageQueue可以分布在多个broker节点上，实现数据的分布式存储，分担磁盘存储和网络IO

一个Topic的多个MessageQueue会均匀分摊给消费组内的多个机器去消费

- 在一个消费者组中，**一个MessageQueue只能被组内的一个消费机器去处理**
- 一个消费者机器可以负责多个MessageQueue的消息处理

## 客户端

### Producer 消息生产者

#### 生产者组



#### 投递消息策略

生产者会从NameServer拉取topic的元数据，得到topic对应的哪些MessageQueue，这些MessageQueue在哪个Broker地址

根据负载均衡算法（或者message自带的MessageQueueSelector）找到对应的Queue地址进行投递

> 类似微服务中的ribbon 基于客户端的负载均衡

### Consumer 消息消费者

#### 消费进度

> 开始消费位置

##### 查询消息

消费者客户端从broker读取消息时，会根据消费者客户端对应的MessageQueue和消费进度查询ConsumerQueue文件找到消息在commitLog中的物理存储位置（offset），加载消息数据返回给客户端

##### 消费完成

消费者客户端消费完消息后，会提交最新的消费进度到broker，broker会保存客户端的消费进度

> 消费进度与MessageQueue没有关系
>
> 会在consumer客户端本地和broker维护两份消费进度
>
> 如果是广播模式消费，消息的消费进度是保存到本地，如果是集群消费模式，消息的消费进度则是保存到 Broker，但无论是保存到本地，还是保存到 Broker，消费者都会在本地留一份缓存

#### 消费者组

一个topic可以被多个消费者组订阅，每个消费者组有一个独立的消费进度（即一条消息，会被topic下的所有消费者组消费）

> ，类似点对点模式（point to point， queue）
>
> 不同的消费者组之间，类似发布/订阅模式（publish/subscribe，topic）

##### 集群模式

同一个消费者组内部有多个消费者进程，他们共用一个消费进度（即一条消息，只会被一个消费者组中的一个消费进程消费）

> 默认设置是集群模式

##### 广播模式

开启广播模式后，消费者客户端维护一个独立的消费进度；消费者获取一条消息，所有广播模式的客户端都会获取到消息

> 通过修改消费者客户端设置来开启广播模式 `consumer.setMessageModel(MessageModel.BROADCASTING);`



# 集群

### 主从集群

rocketmq默认是集群模式，分为Master节点和slave节点

写数据

> 没有规定读写分离，主从节点共同分担读写负载
>
> - master写负载高时，会让客户端从客户端拉取数据
> - 当slave不能跟master数据同步时，只能从master同步

### 分布式节点

多组Master-Slave集群将数据分布式存储，每一个主从集群作为分布式存储的一个节点



